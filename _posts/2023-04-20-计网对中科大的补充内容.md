### HTTP

【HTTP/1.1，HTTP/2和HTTP/3的区别】 https://www.bilibili.com/video/BV1vv4y1U77y/?share_source=copy_web&vd_source=1184c486dc565ae483367f8f3e51262e

#### HTTP2/HTTP3

HTTP1.0是非持久化连接，HTTP1.1是持久连接。各家浏览器允许的持久连接数不一样，都不算多。

为了缓解这个问题，HTTP1.1采用了流水线化的持久连接，也就是流水线技术。

**但是流水线技术有一个坑，那就是响应的时候必须按照请求的顺序接受，请求是一二三四，接收的时候也要按一二三四的顺序**。

这也就导致了所谓的队头阻塞问题：在一个连接上，同一时间只能处理一个请求-响应对，如果前一个请求的响应未返回，后续的请求必须等待。

HTTP2：

- 报文的首部和主体都压缩。HTTP1只压缩主体
- **二进制分帧：** HTTP/2 使用二进制格式将数据拆分为多个帧，可以并行传输多个帧，从而提高了传输效率。
- **多路复用：** 在单个连接上可以同时传输多个请求和响应，消除了阻塞的问题，提高了性能。
- **头部压缩：** 使用HPACK算法对头部进行压缩，减少了传输的开销。
- **服务器推送：** 服务器可以在客户端请求之前主动推送相关资源，加快页面加载速度。
  - 所谓的服务器推送就是，比如你请求一个HTML，服务器那边主动把这个HTML里面会用到的其他对象，比如`js/css`之类的一起发给你。但是万一用户只是不小心点到的呢？用户不就直接关了，白浪费了。

#### 状态码

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

#### cookie

cookie技术有4个组件：

1. 在HTTP响应报文中的一个cookie首部行
2. 在HTTP请求报文中的一个cookie首部行；
3. 在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理；
4. 位于Web站点的一个后端数据库

举个例子来说明Cookie的工作过程：如下图。假定我们已经访问过一次eBay网站，然后这是我们首次访问Amazon网站。因为之前已经访问过eBay，所以用户浏览器本地的Cookie文件中包含了与eBay相关联的一个Cookie项`<eBay:8734>`

1. 当我们的浏览器发出的请求报文到达该Amazon Web服务器时，该Web站点将产生一个唯一识别码，并**以此作为索引**在它的后端数据库中产生一个表项。

2. 接下来Amazon Web服务器用一个包含`Set-cookie：`首部的HTTP响应报文对我们的浏览器进行响应，其中`Set-cookie：`首部含有该识别码。

   例如该首部行可能是`Set-cookie:1678`

3. 当我们的浏览器收到了该HTTP响应报文时，它会看到该`Set-cookie：1678`首部。该浏览器**在它管理的特定cookie文件中添加一行**，该行包含服务器的主机名和在Set-cookie:首部中的识别码

4. 当我们继续浏览Amazon网站时，每请求一个Web页面，其浏览器就会查询该cookie文件并抽取我们在这个网站的识别码，并放到HTTP请求报文中包括识别码的cookie首部。发往该Amazon服务器的每个HTTP请求报文都包括以下首部行：`Cookie: 1678`

如果我们再次访问Amazon站点，比如说一个星期后，我们的浏览器会在其请求报文中继续放入首部行`cookie： 1678` 。Amazon将根据过去在Amazon访问的网页向我们推荐产品。如果我们也在Amazon注册过，即提供了她的全名、电子邮件地址、邮政地址和信用卡账号，则Amazon能在其数据库中包括这些信息，将我们的名字与识别码相关联（以及她在过去访问过的本站点的所有页面）



cookie可以用于标识一个用户。用户首次访问一个站点时，可能需要提供一个用户标识（可能是名字）。在后继会话中，浏览器向服务器传递一个cookie

首部，从而向该服务器标识了用户。因此cookie可以在无状态的HTTP之上建立一个用户会话层

<img src="https://i.imgur.com/Na0BVNV.png" alt="image-20230825135729169" style="zoom: 80%;" />

### ICMP

ICMP通常被认为是IP的一部分，但从体系结构上讲它位于IP之上，因为ICMP报文是承载在IP分组中的。

当一台主机收到一个指明上层协议为ICMP的IP数据报时（上层协议编码为1）,它分解出该数据报的内容给ICMP

ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节。

<img src="https://i.imgur.com/0DU2Tft.png" alt="image-20230825134233248" style="zoom:80%;" />

Traceroute的实现原理：

为了判断源和目的地之间所有路由器的名字和地址，源主机中的Traceroute向目的地主机发送一系列普通的IP数据报。这些数据报的每个携带了一个具有**不可达UDP端口号的UDP报文段**。第一个数据报的TTL为1,第二个的TTL为2,第三个的TTL为3,依次类推。该源主机也为每个数据报启动定时器。

当第N个数据报到达第N台路由器时，第N台路由器观察到这个数据报的TTL正好过期。根据IP协议规则，路由器丢弃该数据报并发送一个ICMP告警报文给源主机（类型11编码0）。该告警报文包含了路由器的名字和它的IP地址。当该ICMP报文返回源主机时，源主机从定时器得到往返时延，从ICMP报

文中得到第n台路由器的名字与IP地址。

Traceroute源主机是怎样知道何时停止发送UDP报文段的呢？前面讲过源主机为它发送的每个报文段的TTL字段加1。因此，这些数据报之一将最终沿着这条路到达目的主机。**因为该数据报包含了一个具有不可达端口号的UDP报文段，该目的主机将向源发送一个端口不可达的ICMP报文**（类型3编码3）。当源主机收到这个特别的ICMP报文时，知道它不需要再发送另外的探测分组。（标准的Traceroute程序实际上用相同的TTL发送3个一组的分组，因此Traceroute输出对每个TTL提供了 3个结果。）



### DHCP

DHCP 允许主机自动获取（被分配）一个IP地址。除了主机IP地址分配外，DHCP还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器地址（常称为默认网关）与它的本地DNS服务器的地址。

即插即用的，不需要做配置的协议。



DHCP是一个C-S架构的协议。客户通常是新到达的主机，它要获得包括自身使用的IP地址在内的网络配置信息。

在最简单场合下，每个子网将具有一台DHCP服务器。如果在某子网中没有服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理知道用于该网络的DHCP服务器的地址。



当一台主机新加入本子网的时候，DHCP分为四个步骤：

1. DHCP服务器发现。一台新到达的主机的首要任务是发现一个要与其交互的DHCP服务器。这可通过使用DHCP发现报文（DHCP discover message）来完成。UDP报文，67号端口，源IP是“本主机”源IP地址`0.0.0.0`，目标IP是广播地址`255.255.255.255`。DHCP客户将该IP数据报传递给链路层，链路层然后将该帧广播到所有与该子网连接的节点。

2. DHCP服务器提供。DHCP服务器收到一个DHCP发现报文时，用DHCP提供报文(DHCP offer message)向客户做出响应，该报文向该子网的所有节点广播，仍然使用IP广播地址255. 255. 255. 255（不广播找不到发出请求的客户端呀）。因为在子网中可能存在几个DHCP服务器，该客户也许会发现它处于

   能在几个提供者之间进行选择的优越位置（也即可能收到多个DHCP Offer报文）。每台服务器提供的报文包含有：**收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及IP地址租用期**。

3. DHCP请求。新到达的客户从一个或多个服务器提供中选择一个，并向选中的服务器提供用DHCP请求报文(DHCP request mess昭e)进行响应，**回显**配置的参数。

   - 为什么要有DHCP请求报文呢？因为客户端可能会收到多个DHCP服务器给的多个Offer，它总要告诉他们，自己选了哪一个Offer吧。

4. DHCP ACKO 月艮务器用 DHCP ACK 报文(DHCP ACK message)寸 DHCP 请求报文进行响应，证实所要求的参数。 

从移动性角度看，DHCP确实有非常严重的缺陷。因为每当节点连到一个新子网，要从DHCP得到一个新的IP地址，当一个移动节点在子网之间移动时，就不能维持与远程应用之间的TCP连接。也就是，DHCP不能满足移动IP技术（移动IP技术允许移动节点在网络之间移动时使用其单一永久的地址）

### ARP

ARP**只为在同一个子网上的**主机和路由器接口解析IP地址。如果美国加利福尼亚州的一个节点试图用ARP为美国密西西比州的一个节点解析IP地址，ARP将返回一个错误。

ARP的报文结构：一个ARP分组有几个字段，包括发送和接收IP地址及MAC地址。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问**子网上所有**其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址

ARP的工作原理：

每台主机或路由器在其内存中具有一个ARP表（ARP table）,这张表包含IP地址到MAC地址的映射关系。

该ARP表也包含一个寿命（TTL）值，它指示了从表中删除每个映射的时间。注意到这张表不必为该子网上的每台主机和路由器都包含一个表项；某些可能从来没有进入到该表中，某些可能已经过期。

<img src="https://i.imgur.com/Cetko2M.png" alt="image-20230825155631808" style="zoom:67%;" />



举个例子说明一下ARP协议是如何工作的：

现在假设主机222. 222. 222. 220要发送一个数据报，该数据报要IP寻址到本子网上另一台主机或路由器。发送主机需要获得给定IP地址的目的主机的MAC地址。如果发送方的ARP表具有该目的节点的表项，这个任务是很容易完成的。

但如果ARP表中当前没有该目的主机的表项，又该怎么办呢？在这种情况下，发送方用ARP协议来解析这个地址。

1. 首先，发送方构造一个称为ARP分组（ARP packet）的特殊分组。222. 222. 220向它的适配器传递一个ARP查询分组，并且指示适配器应该用MAC广播地址（即FF-FF-FF-FF-FF-FF）来发送这个分组。适配器在链路层帧中封装这个ARP分组，用广播地址作为帧的目的地址，并将该帧传输进子网中。
2. 该ARP查询的帧能被子网上的所有其他适配器接收到，并且（由于广播地址）每个适配器都把在该帧中的ARP分组向上传递给ARP模块。这些ARP模块中的每个都检查它的IP地址是否与ARP分组中的目的IP地址相匹配。
3. 与之匹配的一个给査询主机发送回一个带有所希望映射的响应ARP分组。然后查询主机222. 222. 222. 220能够更新它的ARP表，将得到的IP-MAC地址对应关系加入它的ARP表。

ARP是即插即用的，这就是说，一个ARP表是自动建立的，即它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的节点的表中删除掉。

查询ARP报文是在广播帧中发送的，而响应ARP报文在一个标准帧中发送（意思就是不广播，是点到点的）。



概括一下就是：

1. 在子网内广播一个ARP查询帧，帧中的载荷部分是一个ARP报文。
2. 子网内其他所有的主机都会接受这个ARP查询帧，并将其中的ARP报文传递给ARP协议
3. 与被查询的IP匹配的主机，就回送一个响应ARP分组。然后查询方就得到了他想要的MAC地址。

> 学生们常常想知道ARP是一个链路层协议还是一个网络层协议。如我们所看到的那样，一个ARP分组封装在链路层帧中，因而在体系结构上位于链路层之上。然而，一个ARP分组具有包含链路层地址的字段，因而可认为是链路层协议，但它也包含网络层地址，因而也可认为是为网络层协议。所以，可能最好把ARP看成是跨越链路层和网络层边界两边的协议，即不完全符合我们在第1章中学习的简单的分层协议栈。现实世界协议就是这样复杂！

