# Java核心技术 第11版

# 第1章 Java程序设计概述

- Java是一个完整的平台，有一个庞大的库，其中包含很多可重用的代码，以及一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾回收等服务的执行环境。

## 1.2Java 白皮书的关键术语

### 1.2.6 体系结构中立

这个是关于，`java`是如何做到跨体系结构的可移植性的。

- 编译器生成一个体系结构中立的目标文件格式，这种编译过的代码只要有`java`运行时系统，就可以在不同的处理器上运行。
- `Java`通过生成与计算机体系结构无关的字节码指令来实现这一特性。
- 字节码可以在任何机器上**解释执行**，而且可以动态地转化为本地机器代码。
- 解释型虚拟机指令会比全速运行机器代码慢。
- **即时编译：将执行最频繁的字节码序列转换成机器码。**

### 1.2.7 可移植性

- **与C和C++不同，Java规范中没有“依赖具体实现”的地方。基本数据类型的大小以及有关运算的行为都有明确说明。**
  - 比如`Java`中`int`永远是32位的，`C`则“依赖具体实现”。数值类型有固定的字节数。
  - 个人理解对可移植性的好处在于，不管移植到什么平台去，用什么编译器，都不用担心由于不同编译器实现的`int`位数不同，使得要修改代码。
- 二进制数据使用固定的格式进行传输和存储。
- 字符串用`Unicode`储存。

### 1.2.8 解释型

- Java解释器可以在任何移植了解释器的机器上直接执行Java字节码。

### 1.2.9 高性能

- **即时编译**
  - 字节码可以在运行时动态地转换成相应的CPU的字节码。
  - 内联。

## 1.5 关于Java的常见误解

- **Java是解释型的：**
  - 早期的`Java`确实是解释型的。现在`Java`虚拟机使用了**即时编译器**，因此采用`Java`编写的“热点”代码（指那些运行频率高的字节码）运行速度与`C++`相差无几，有时候更快。
- `JavaScript`不是`Java`的简易版，`Java`是强类型的，`JavaScript`则不是。

# 第2章 Java 程序设计环境

## 2.1 安装Java开发工具包

### 2.1.1

- 一些Java术语：
  - JDK ：Java 开发工具包
  - JRE ：Java运行时环境，只包含虚拟机 
  - SE：标准版
  - EE：企业版
  - `OpenJdk`:Java SE的一个开源实现

# 第3章 Java的基本程序设计结构

## 3.1

- **Java类的命名必须以字母开头，且不能使用保留字**
- **源代码的文件名必须与公共类的名字相同**

## 3.2 注释

- 可以用来自动生成文档的第三种注释方法：
  - 以`/**`开始，以`*/`结束。

## 3.3 数据类型

### 3.3.1 整型

- 有一个`byte`型的有符号数。大小为一字节，范围为-128 到 +127。
- 要用二进制表示一个数，在数前面加`0b`或`0B`前缀。
- **Java没有任何无符号形式的整型。**但是有相应的类满足这个需求。

### 3.3.2 浮点型

- 三个特殊的浮点值
  - `NaN`:Not A Number。`Double.NaN`
  - 正无穷。`Double.POSITIVE_INFINITY`
  - 负无穷。`Double.NEGATIVE_INFINITY`
- 检查一个值`x`是否是特殊的浮点值：

```java
//错误的写法
x == Double.NaN;
//正确的写法：
Double.isNaN(x);
```

- 浮点值不适用于不接受舍入误差的计算。
  - 使用`BigDecimal`类。

### 3.3.3 char

### 3.3.4 Unicode和char

- 建议不使用`char`，将字符串作为抽象数据类型处理。

### 3.3.5  boolean 类型

- **整数和`boolean`类型不能相互转换**

## 3.4 变量与常量

### 3.4.1 声明变量

- 变量名大小写敏感。以字母开头，由字母与数字序列构成。
  - 字母与数字的范围更大，比如希腊字母也在这个字母的范围内。

### 3.4.2 变量初始化

- 不能使用未初始化的值。必须对变量进行显式的初始化，不过默认初始化为0和null。

- 关键字`var`。

### 3.4.3 常量

- 使用`final`关键字指示常量。
  - 目前`const`并未使用的关键字。
  - `final`表明这个变量只能被赋值一次。
  - 类常量可以用`static final`定义在main方法的外部。

### 3.4.4 枚举

## 3.5 运算符

### 3.5.1 运算符

### 3.5.2 数学函数与常量

- 使用`Math`类的各种函数

```java
import static java.lang.Math.*;
/*求余数的函数，用来处理对负数做模运算的*/
Math.floorMod(-1 , 2);// -1 % 2
Math.PI;//π
Math.E;//自然常数e
```

- `Math`类提供了一些比单纯使用运算符更好的安全性。
  - 运算符对溢出只会悄悄返回错误的结果而不做任何提醒。而使用Math的函数可以捕获这个异常。

### 3.5.3 数值之间的转换

- 二元运算符的转换优先级
  - `double` > `float` > `long` > `int`

- 会导致信息丢失的转换：
  - `int` ==> `float`
  - `long` ==> `float`
  - `long`==> `double`

### 3.5.4 强制类型转换

```java
//对浮点数进行舍入运算得到最接近的整数
int x = (int)Math.round(9.997);//返回值为long
```

### 3.5.5  +=  -= etc

### 3.5.6 ++ --

- 狗都不用

### 3.5.7 关系和Boolean运算符

- **逻辑与、逻辑或的短路求值**
- 三元操作符狗都不用。



### 3.5.8 位运算符

- 移位
  - java的右移操作一定是算术右移。也即`>>`使用符号位填充。`>>>`运算符则使用0填充高位。
- 按位与或非
- 没了

### 3.5.9 运算符优先级

## 3.6 字符串

- Java并没有内置的字符串类型，而是Java库中预定义的`String`类。

### 3.6.1 子串

```java
//substring(int startPos , int destPos);
//截取从startPos到destPos - 1 的字符
String H = "Hello";
String he = H.substring(0,3);//位置0到2的字符。
```

### 3.6.2 拼接

- 使用`+`拼接，被拼接的两个字符串之间并不会自动添加空格。
  - 非字符串的值与字符串拼接时会自动转换为字符串。
- `String.join(String ...)`
  - 将多个字符串拼接并使用给定的分隔符分割。

### 3.6.3 不可变字符串

- `String`类中并没有提供直接修改字符串中某个单个的字符的方法。
  - 如并不能直接将`Hello`修改为`Help!`。C的话直接从底层数组修改就好。
  - Java的`String`类其实更类似C的`char *`，而不是`char[]`数组。
- 使用字符串拼接。

```java
String str = "Hello";
str = str.substring(0,4) + "p!";
```

- 由于不能直接修改字符串中某个特定的字符所以`String`类称作不可变类。
  - 编译器可以让字符串共享。

### 3.6.4 检测字符串相等

- 使用`string1.equals(string2)`，不使用`==`。
  - ==检测的是地址是否相等。

### 3.6.5 空串与null

- **不是同一个东西**。
  - 空串(`""`)是长度为零的字符串。
  - `null`表示不与任何对象关联。
  - 检查字符串是否为`null`使用`==`，空串使用`str.equals("")`。
  - 检查一个字符串既不是空串也不是`null`。**先检查是不是null**。

### 3.6.6 码点与代码单元

略捏，不想看。

### 3.6.7 String API 

- 看文档的事
- Stack Overflow的事

### 3.6.9 构建字符串

- 使用字符拼接(`+`)来创建字符串很耗时间和空间。
  - 每拼接一个字符串都要创建一个新的`String`对象。
- 使用`StringBuilder`类。

```java
StringBuilder builder = new StringBuilder();
builder.append("Hello");
builder.append("World");
String HW = builder.toString();//HelloWorld, 单词之间没有空格
```

## 3.7 输入与输出

### 3.7.1 输入

- `Scanner`类

```java
import java.util.*;
Scanner in = new Scanner(System.in);//创建与标准输入流关联的scanner对象
int n = in.nextInt();//读取一个数
String str = in.nextLine();//读取一整行
String Aword = in.next();//读取一个单词，由空白分割
double d = in.nextDouble();
```

### 3.7.2 格式化输出

- `System.out.Printf()`

### 3.7.3 文件输入输出

- 读取文件：
  - 构造一个与文件关联的`Scanner`类对象即可。
  - 构造器的参数读文档去。
  - 注意路径反斜杠的转义。
  - 要已知文件的编码。
- 写入文件
  - 构造与一个文件关联的`PrintWriter`对象。
  - 要已知文件名及编码。
  - 正常调用`printf`等函数即可。

```java
import java.util.*;
import java.io.*;
PrintWirter out = new PrintWriter("..\\file.txt",StandardCharacters.UTF_8);
out.print("Hello");
```

## 3.8 控制流程

- 不看

- `break`
  - 带标签的相当于`goto`，否则和C的没什么区别。
- `continue`和C完全一样。

## 3.9 大数

- 用来处理需要绝对精度的算术运算的时候使用。
  - `BigInteger`：任意精度的整数运算
  - `BigDecimal`：任意精度的浮点数运算
  - 加减乘除都必须使用相应的方法，而不是直接使用运算符。

```java
import java.math.*;
import java.util.*
//将基本类型的数转换为BigInteger对象
BigInteger a = BigInteger.valueOf(114514);
//构造巨巨巨巨大的数
BigInteger reallyBig = new BigInteger("1145141919180");
BigInteger result = a.add(reallyBig);//result = a + b
```

- 其他的读文档吧。



## 3.10 数组

### 3.10.1声明数组

- 初始化数组的语法糖。

```java
int[] a = new int[5];
int[] b = {1,2,3,4, 5};
int[] c;
c = new int[] { 1 , 2, 3, 4};
```

- **可以声明长度为0的数组。**
  - 与`null`并不相同。

### 3.10.2 访问数组元素

### 3.10.3 for-each

### 3.10.4 数组拷贝

- `Arrays.copyOf()`
- `System.ArrarCopy()`

### 3.10.5 命令行参数

- **程序本身的名字并不在`args[]`数组中。**

```java
public class example {
    public static void main(String args[]) {
        if (args.length == 0 || args[0].equals("-h")) {
            System.out.print("Hello,");
        }
        else if(args[0].equals("-g")) {
            Systm.out.print("Goodbye,")
        }
        //打印剩下的命令行参数
        for(int i = 1 ; i < args.length ; i ++) {
            System.out.print(args[i] + " ");
        }
    }
}
java example -h nice World
    ===> Hello,nice World
//args[0] ==> "-h"
//args[1] ==> "nice"
//args[2] ==> "World"
```

### 3.10.6 数组排序

- 调用API的事

### 3.10.7 多维数组

- 不看，知道底层怎么回事就行。
- `for-each`循环要嵌套两层

### 3.10.8 不规则数组

- 二维数组由于底层实现的关系，可以交换两行。
- 也是由于同样的原因，二维数组的每一行的行长度甚至可以不一样，也就是不规则数组

```java
//初始化一个第i行有i个元素的不规则数组
int[][] a = new int[10][]//10行，但是不确定每一行的元素个数
for (int i = 0 ; i < 10 ; i ++) {
    a[i] = new int[i + 1];
}
```

# 第4章 对象与类

## 4.1 面向对象程序设计概述

- 每个对象对用户公开特定的功能，隐藏具体的实现。

### 4.1.1 类

- 封装：将数据和行为组合在一个包中，并将具体的实现方式对用户隐藏起来。
  - 对象中的数据：实例字段，`instance field`。
  - 实例字段的值的集合称为对象的状态。
  - 程序**只能**通过对象的方法与对象的数据进行交互。

- Java中所有的类都扩展自`Object`超类。
- 继承。

### 4.1.2 对象

- 对象的状态改变必须是通过调用对象的方法，如果不经过调用方法就可以改变对象的状态，只能说明破坏了封装性。
- 每个对象都有唯一的标识。

### 4.1.3 识别类

### 4.1.4 类之间的关系

- 依赖：use - a
- 聚合：has - a
- 继承：is - a

## 4.2 使用预定义类

- 有些类是没有数据的，不是所有的类都表现出面向对象的典型特征。

### 4.2.1 对象与对象变量

- 要使用对象，必须先构造对象并指定其初始状态，然后对对象应用方法。
- 构造器是一种特殊的方法，用来构造并初始化一个对象。
  - 构造器的名字应该和类名相同。
  - 对象变量引用一个对象
  - `new`。
- **对象变量并没有实际包含一个对象，它只是引用一个对象。任何对象变量的值都是对存储在另一个位置的某个对象的引用。**

### 4.2.2 

### 4.2.3 更改器方法与访问器方法

- 更改器方法：
  - 会更改原有对象的实例字段。
  - 破坏性方法。
- 访问器方法：
  - 访问原有的方法，但不对它做出改变
  - 返回一个新的对象。
  - 非破坏性方法。

## 4.3 用户自定义类

### 4.3.1 employee 类

- **一个`.java`文件中可以有多个类的，但是只能有一个`public`类，`.java`文件的名字要和`public`类相同**
- **类可以没有访问修饰符的，比如同一个文件中的类。**

```java
public class employeeTest {
    /**
    *实例字段
    */
    /**
    *方法
    */
    public static void main(String[] args) {
        /**
        *要有main
        */
    }
 }
//这个类不要嵌套到public类里面去
class employee {
        /**
        *实例字段
        */
        /**
        *方法
        */
    }
```

- 编译的时候会生成多个`.class`文件，`employee.class`和`employeeTest.class`

### 4.3.2 多源文件的使用

### 4.3.3 剖析employee类

- `public`访问修饰符
  - 任何类的任何方法都可以调用`public`的方法
  - 不要将实例字段标记为`public`

- `private`：访问修饰符

- **实例字段本身也可以是某一种类的一个对象。**

### 4.3.4 从构造器开始

- 构造器与类同名。
- 每个类可以有多个构造器。
- 构造器可以有0个到多个参数。
- **构造器没有返回值**
- 构造器总是与`new`一起使用。
- 在构造器中声明与实例字段同名的局部变量会造成同名的实例字段被局部变量遮蔽。

### 4.3.5 使用var声明局部变量

- **如果可以通过变量的初始值反推它们的类型，就可以用`var`关键字声明局部变量**

- **`var`关键字只能用于声明局部变量**
- **参数和字段必须声明类型**

### 4.3.6 使用null引用

- 对`null`使用方法会产生`NullPointerException`。

### 4.3.7 显式参数和隐式参数

- 显式参数：函数签名括号参数表里的
- 隐式参数：可以用`this`来指代



### 4.3.8 封装的优点

### 4.3.9 基于类的访问权限

- 一个方法可以访问`所属类的所有对象`的私有数据。不仅局限于隐式参数。

### 4.3.10 私有方法

- 只要方法是`private`的那么就可以保证这个方法不会在除了所属类以外的其他地方被使用。

### 4.3.11 final实例字段

- **被定义为`final`的实例字段必须要在构造对象时初始化**
  - `final`修饰的字段只能被赋值一次。

## 4.4 静态字段与静态方法

- 有关`static`修饰符

### 4.4.1 静态字段

- 被标记为`static`的实例字段将被类的所有实例共享。
  - 即使没有对象，`static`字段也存在，它属于类，不属于任何单个对象。

### 4.4.2 静态常量

- 即`static final`标记的变量。

```java
public class Math {
    public static final double PI = 3.1415926535;//即使声明为public也没关系，final保证了PI的值不会被修改
}
//使用Math.PI 来访问
//好处在于，可以无需构建一个Math对象就可以访问圆周率的值。
```

### 4.4.3 静态方法

- 静态方法是不在对象上执行的方法。
  - 可以认为静态方法没有隐式参数。
  - 静态方法不能访问实例字段，因为它不在对象上执行操作。
  - 静态方法可以访问静态字段。
- **但是是可以用一个实例对象来调用静态方法的。不过还是推荐用类名调用静态方法。**
- 适用静态方法的情况：
  - 方法不需要访问对象状态，它所需要的所有数据通过显式参数提供。
  - 方法只需要访问类的静态字段。

### 4.4.4 工厂方法

- 静态方法的一种常见用途。
  - 比如要初始化一个Date对象，为当前的时间，`Date now = Date.now()`比`Date now = new Date()`可读性好多了。
  - 为什么不是 `Date now = new now()`?因为构造器要和类同名。

### 4.4.5 main 方法

- main方法不对任何对象进行操作。
- 其实每个类都可以有一个`main`方法用作测试，测试完毕后甚至可以不需要删掉，在程序实际运行时这个测试用的`main`方法永远不会运行。

## 4.5 方法参数

- Java是按值调用传递参数。
  - 方法不能修改基本数据类型的参数。
  - 方法可以修改对象类型的参数的状态。

## 4.6 对象构造

### 4.6.1 重载

- **重载：多个方法有相同的名字，不同的参数。**
  - 构造器也是一种方法。构造器重载机制。
  - `Java`允许重载任何方法。不局限于构造器。
  - 编译器根据方法调用给定的参数查找匹配的方法的过程称作重载解析(`overloading resolution`)。

### 4.6.2 默认字段初始化

- **局部变量与字段的一个重要区别**
  - 方法中的局部变量不初始化无法使用
  - 在类中实例字段不显式初始化则会被赋予默认值

### 4.6.3 无参数的构造器

- 用无参数构造器构造对象，对象的实例字段被设置为默认值。
- 如果写一个类时没有编写构造器，会默认提供一个无参数构造器。
- **如果提供了有参数构造器，没有显式提供无参数构造器，在构造对象时无法合法调用无参数构造器（构造对象时必须通过参数）。**
- **当且仅当**类没有任何其他构造器时，才会得到一个默认的无参数构造器。

```java
//显式提供无参数构造器，这样写即可。
public ClassName() {
    //什么都不写。
}
ClassName d = new ClassName();
```

### 4.6.4 显式字段初始化

- **可以直接在类定义中为任何字段赋值**

```java
public class LinkedList {
    private int size = 0;
}
//如果一个类的所有构造器都希望把某个字段设置为某个固定初值，就可以直接先在类定义中显式初始化它。
```

- **在类定义中为字段赋值，初值不一定是基本类型，不一定是常量。**

```java
public class LinkedList {
    //在类定义中初始化
    private Node head = new Node();//构造器
    private int size = InitSize();//函数调用
    private int InitSize() {
        return 0;
    }
}
```

### 4.6.5 参数名

- `this`在构造器中的使用而已

### 4.6.6 调用另一个构造器

- 在一个构造器中使用`this`来调用同一个类中的另外一个构造器

```java
public class e {
    private int A;
    private int B;
    private String str;
    public e(int a , int b) {
        A = a;
        B = b;
    }
    public e(int a, int b, String s) {
        this(a,b);
        str = s;
    }
}//各个构造器本来重复的代码，只需要写一次
```

### 4.6.7 块初始化

- 不常见的机制，不管。
- `JDK7`之前都可以利用块初始化来编写没有`main`方法的`"Hello World"`

### 4.6.8 对象析构

- `Java`不支持析构器，因为它会完成自动的垃圾清理回收。

## 4.7 包



### 4.7.1 包名

- **使用包的主要原因是确保类名的唯一性**。
  - 重名的类放不同的包即可。
  - 使用域名的逆序作为包名确保唯一性，可以再追加过程名。

### 4.7.2 类的导入

- **一个类可以使用所属包中所有的类，以及其他包中的公共类（public class）。**
- `import`语句位于源文件的顶部，但是位于`package`语句的后面。
- 只能使用`*`导入一个包。
  - `import java.*.*`不可行。
- 通过完整的指出类名，其实可以避免使用`import`机制，所以`import`并不是`#include`。

### 4.7.3 静态导入

- **允许导入静态的方法和静态字段，而不只是类**

### 4.7.4 在包中增加类

- 想将类放入包中，将包的名字放在源文件的开头。
- 没有在源文件中放置`package`语句，这个文件就属于无名包。无名包没有包名。



### 4.7.5 包访问

**对类、方法、变量**：

- `public`：可由任意类使用。
- `private`：只能由定义它们的类使用。
- 没有指定是`public`还是`private`：可以被同一个包中的所有方法访问。

- **变量必须显式的标注为`private`，否则将默认为包可访问，会破坏封装性。**



### 4.7.6 类路径

- 类存储在文件系统的子目录中，**类的路径必须与包名相匹配**。
- 类也可以存储在`JAR`文件中，压缩形式的类文件和子目录。
- 关于如何保证类文件可被多个程序共享：看书吧 不写。

### 4.7.7 设置类路径

## 4.8 JAR文件

- `JAR`：Java归档文件。
  - 可以包含类文件
  - 也可以包含图像和声音等其他文件。
  - ZIP压缩的。

### 4.8.1 创建JAR文件

- 使用`jar`工具。命令行。

```java
jar options file1,file2
```

### 4.8.2 清单文件

### 4.8.3 可执行jar文件

### 4.8.4 多版本JAR文件

## 4.9 文档注释

JDK包含一个很有用的工具，Javadoc，它可由源文件生成一个HTML文档。

### 4.9.1 注释的插入

### 4.9.2 类注释

- 放在`import`之后，类定义之前，`/** ...*/`。

### 4.9.3 方法注释

- 放在方法定义之前，`/**...*/`。
- 除了通用标记还有一些可用标记。

```java
/**
*a example
*@param void
*@return nope
*@throw a exception
*/
```

### 4.9.4 字段注释

```java
/**
*PI
*/
public static final PI = 3.1415926535;
```

### 4.9.5 通用注释

- 看文档的事

```java
/**
*@author name
*@version text
*@
*/
```

### 4.9.6 包注释

### 4.9.7 注释抽取

- 看文档的事

## 4.10 类设计技巧

- 保证数据私有。
- 对数据进行初始化。Java**不会为你初始化局部变量**。
- 不要在类中使用过多基本类型。
- 某些字段可能并不需要`getter()`和`setter()`。

# 第5章 继承

- 继承：
  - 基于已有的类创建新的类。
  - 继承已存在的类就是复用这些类的方法。
  - 可以新增一些字段和方法。

- 有关反射的不仔细了解。

## 5.1 类、超类和子类

- `is - a` 关系是继承的明显特征。

### 5.1.1 定义子类

- **子类比超类要有的功能更多，封装的数据也更多。**
  - 添加更多方法。
  - 增加更多字段
  - **子类继承了超类的的方法和字段。**

```java
public class SubClass extends SuperClass {
    /**
    *added methods and fields
    */
}
```

### 5.1.2 覆盖方法 

- `@override`。
  - 覆盖超类中的同名方法的时候，可能需要调用超类中的这个方法。使用`super`。
  - `super`存在的原因是，尽管子类继承了超类的字段，但是由于超类的字段是`private`的，所以子类也没办法访问，只能通过超类提供的方法来访问。
- `super`只是一个指示编译器调用超类方法的关键字，与`this`不同。

```java
//以下写法会导致死循环
/**
*求经理的工资，基本工资加奖金
*/
public int getSalary() {
    return getSalary() + bonus;//本意是调用超类中的求工资方法，返回基本工资。
}
//正确的写法
public int getSalary() {
    return super.getSalary() + bonus;//Super调用超类中的求工资方法，返回基本工资。
}
```

- **子类可以增加方法，字段或覆盖超类的同名方法，但是不会删除超类的任何字段和方法。**

### 5.1.3 子类构造器

-  使用`super`调用超类构造器。
  - 你要构造一个子类对象，那你首先要构造一个超类对象。一个经理首先是一个员工，然后才是一个经理。
- `super`存在的原因还是，子类无法直接访问超类的`private`字段，所以必须通过先调用超类构造器来初始化这些从超类继承来的字段。
- **子类构造器的第一条语句一定是`super`调用超类构造器。**
  - 子类构造器没有显式调用超类构造器，则默认调用超类的无参数构造器。超类不存在无参数构造器则编译器报错。

```java
/**
*经理类继承了员工类，比员工类多了一个奖金
*/
public Manager(String name , int salary , int month , int year) {
    super(name,salary,month,year);
    bonus = 0;
}
```

- **多态：一个对象变量可以保存扩展自它所属类的任意子类对象。**
- **动态绑定：虚拟机能够知道上述对象变量所引用的对象的实际类型，并能根据实际类型选择正确的方法。**

### 5.1.4 继承层次

- 继承链

### 5.1.5 多态

- 任何超类对象变量出现的地方都可以用子类对象去替换。
- 一个超类类型的对象变量可以引用其任何子类的对象。反之不一定成立。
- 不能将超类的引用赋给子类对象变量。因为子类对象会有更多的字段。

### 5.1.6 理解方法调用

- 看一遍就是了
- **返回类型不是签名的一部分，签名由函数名和参数列表组成。子类覆盖超类同签名方法时允许改变返回类型。**
- **覆盖方法时，子类的方法的可见性不能低于超类方法。如果超类方法是`public`，子类也必须是。**



### 5.1.7 阻止继承：final类和方法

- 希望阻止其他人用这个类来扩展得到子类的时候，使用`final`类。
  - 不允许扩展的类称为`final`类。
  - 定义类的时候使用`final`修饰符即可。

```java
public final class FinalClass extends Object {
    
}
```

- 类中的某个特定方法也可以被声明为`final`。子类不能覆盖被声明为`final`的方法。
  - `final`类中的所有方法自动成为`final`方法。

```java
public final int getSalary() {
    //这个方法不能被经理类中的方法覆盖
}
```

- **`final`类中的字段并不自动成为`final`**。
- 将方法或类声明为`final`是为了确保它们不会在子类中改变语义。`String`类就是`final`的。



### 5.1.8 强制类型转换

- **超类引用赋给子类变量时，必须要强制类型转换才能通过编译器检查。**
- 在进行强制类型转换之前，使用`instanceof`操作符查看是否能成功完成转换

```java
if (Amanager instanceof employee) {
   epmloyee e = (employee) Amanager;
}
```

- 使用子类特有的方法时才可能需要强制类型转换。

### 5.1.9 抽象类

- 如果自下而上的在继承层次结构中上移，位于上层的类更具有一般性，可能更加抽象。

- 抽象程度更高的方法，使用`abstract`关键字，这样不需要提供实现的方法。
  - 比如对`person`类，有两个子类`employee`和`student`。有一个方法`getDescription()`返回对人的描述。
  - 这个方法在子类中各自实现不同，而在`person`类中就不好去具体实现，我们把它声明为`abstract`就好。

- **包含一个或多个`abstract`方法的类本身必须被声明为`abstract`**
  - 抽象类还可以包含字段和有具体实现的方法。

```java
public abstract class Person {
    private String name;
    public Person(String name) {
        this.name = name;
    }
    public abstract String getDescription();//分号，不需要具体实现
    public String getName() {
        return name;
    }
}
```

- 抽象方法充当着占位方法的角色，它们在子类中具体实现。
- 扩展抽象类的两种选择：
  - 在子类中部分实现抽象类中的抽象方法，保留部分或全部抽象方法未具体实现。此时子类也必须是抽象类。
  - 定义全部方法，此时子类不需要被声明为抽象类。

- **即使不含抽象方法，也可以将类声明为抽象类。**
- **抽象类不能实例化，如果一个类被声明为`abstract`，那么不能`new`一个这个类的对象。但是可以创建一个具体子类的对象。**
  - 可以创建一个抽象类的对象变量，但是它只能引用非抽象子类的对象。

```java
//Wrong,Person 为抽象类
Person p = new Person();
//可以
Person p = new Student();
```

### 5.1.10 受保护访问

- 有时候可能希望超类的某个字段，子类可以直接访问，但是被标记为`private`的字段是无法访问的。
  - 此时就用`protected`。
  - 超类中被声明为`protected`的字段是可以被子类访问的。
  - **保护字段只能由同一个包中的类访问（这里没有说同一个包中的子类）**
    - 如果一个子类不属于本包，那么它的对象可以访问对象自己的受保护字段，但是不能访问其他超类对象的受保护字段。
    - 对`protected`方法也是同样的。
  
- 总结一下访问修饰符
  - `private`：仅对本类可见。
  - `public`：对外部完全可见。
  - `protected`：对本包以及所有子类可见。
  - 没有访问修饰符：对本包可见。

## 5.2 Object：所有类的超类

- `Object`类是所有类的超类。Java中每个类都扩展了`Object`。
  - 如果没有明确指出超类，`Object`就被认为是这个类的超类。

### 5.2.1 Object类型的变量

- `Object`类型的对象变量可以引用任何类型的对象。
  - 只能作为用于各种值的泛型容器。要想对其中的内容做具体操作，需要清楚对象的原始类型，并进行强制类型转换。
  - 只有基本类型不是对象。
  - 所有的数组类型都扩展了`Object`类。

### 5.2.2 equals()方法

- `Object`类中实现的`equals()`方法比较的是两个对象的引用是否相等。
- 在子类中定义`equals()`方法时，首先调用超类的`equals()`。
  - 不同属于一个超类肯定不会相等。

### 5.2.3 相等测试与继承

- 关于如何写好`equals()`方法。

### 5.2.4 hashCode方法

### 5.2.5 toString方法

## 5.3 泛型数组列表

### 5.3.1

### 5.3.2

### 5.3.3 

## 5.4 对象包装器与自动装箱

- 需要将基本类型转换为对象时使用。
  - 所有的基本类型都有一个与之对应的类，这些类称作包装器。
  - 包装器类是不可变的，且是`final`的。
- 关于自动装箱和自动拆箱。
  - 编译器负责的工作。
- 比较两个包装器对象是否相等要用`equals()`。

```java
Integer i = Integer.valueOf(3);//装箱
int p = i.intValue(i);//拆箱
```

## 5.5 参数数量可变的方法

- 变参方法。
  - 定义实参个数可变的方法：只要在一个形参的"类型"与"参数名"之间加上三个连续的"."（即"..."，英文里的句中省略号），就可以让它和不确定个实参相匹配。
  - 用`...`。表明可以接受任意数量的对象。
  - 如果接收到的参数类型不同，用`Object...`来接收。
    - `Object...`相当于一个`Object`数组。

- 可以为参数指定任意类型，基本类型也可。

```java
// 变参实例，计算任意个整数中的最大值
public int findMax(int... values) {
    int max = values[1];
    for(int i : values) {
        if (max < i) {
            max = i;
        }
    }
    return max;
}
```

## 5.6 枚举类

- 不看

## 5.7 反射

- 不看

## 5.8 继承的设计技巧

# 第6章 接口 lambda 表达式与内部类



## 6.1 接口

### 6.1.1 接口的概念

- **接口不是类，而是对希望符合这个接口的类的一组需求**。

- `Comparable`接口

```java
public interface Comparable<T> {
    int CompareTo(T other);
}
```

- 接口中的所有方法都是`public`方法。在接口中声明方法时不必提供关键字`public`。
  - **在类中实现时需要显式声明public，不然编译器默认是包访问权限。**
- **接口还可以定义常量。**
- **接口没有实例字段。**
- **接口可以提供方法的具体实现，但是一般不会提供具体实现。**
  - **这些方法不能引用实例字段，因为接口没有。**

- **提供实例字段和方法具体实现的工作应该由实现这个接口的类来完成。**

- 让类实现一个接口：
  - 声明`implements`。
  - **实现接口中定义的所有方法。**

### 6.1.2 接口的属性

- 不能实例化一个接口，换句话说不能`new`一个接口。
- 但是可以声明一个接口类型的对象变量。
  - **接口变量必须引用实现了这个接口的对象。**
  - 可以使用`instanceof`检查一个对象是否实现了某个接口。

- 接口也可以`extends`。
- **接口中可以包含常量**
  - 接口中的字段总是自动的`public static final`。
  - 有些接口中甚至只定义了常量。实现这些接口的类自动继承这些常量。
- 一个类可以实现多个接口，但是只能有一个超类（不支持多重继承）。

```java
public class employee implements Cloneable, Comparable
```

### 6.1.3 接口与抽象类

### 6.1.4 静态和私有方法

### 6.1.5 默认方法

- 给接口的方法提供一个默认实现
  - `default`。
  - 默认方法可以调用接口中的其他方法
  - 默认方法可以保证源代码兼容。细节看书。

### 6.1.6 解决默认方法冲突

- 超类优先
  - 接口默认方法和超类默认方法冲突，超类优先。
- 接口冲突：
  - 编译器报错。
  - 解决的方法是在实现的类中覆盖掉冲突的方法。

### 6.1.7 接口与回调

### 6.1.8 Comparator 接口

- 比较器接口，当你希望使用非`Comparable`中的标准来定义两个对象的大小时使用。
  - 这个方法在比较器对象上调用，而不是在`Comparable`对象本身上调用。

```java
public interface Comparator<T> {
    int compare(T first, T second);
}
public class StringLengthComparator implements Comparator<String> {
    public int compare(String first , String second) {
        return first.length() - second.length();
    }
    public static void main(String[] args) {
        Comparator<String> cmp = new StringLengthComparator<>();
        cmp.compare("ABCD" , "AAAAA");//在比较器上调用
        "ABCD".compareTo("AAAAA");//在Comparable本身上调用
    }
}
```

### 6.1.9 对象克隆

## 6.2 lambda表达式

### 6.2.1 为什么引入lambda表达式

- lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。
- Java想要直接传递一个代码块并不容易，你必须先构造一个对象，这个对象的类要有一个方法包含你需要的那些代码。
- 引入lambda表达式，就是为了能够直接传递一个代码块。

### 6.2.2 lambda表达式的语法

- 语法的具体解析：
  - 一个圆括号，表示这一块代码块是一个函数，或者说，方法。
  - 这个圆括号中存放着方法所需要的参数列表。没有参数也需要圆括号。
  - 花括号中是代码块本体。
  - 我们使用一个箭头来连接本体和圆括号。
  - 我们可以不需要显式的`return`，编译器会自动推断出函数的返回值。
  - 无需指定表达式的返回类型，因为编译器会自动推断。
  - 可以有显式的`return`。
  - 如果圆括号内只有一个参数，而且这个参数的类型可以推导得出，甚至可以不需要圆括号。

- lambda表达式就是代码块以及必须传入代码的变量规范。

```java
//第一个lambda表达式
(String first , String second) -> {
    first.lenght() - second.length();
}
```

- lambda表达式的一种形式：参数，箭头，以及一个表达式。
  - 如果代码要完成的计算一个表达式不够，就可以像写方法一样写一个代码块。
  - 可以包含`return`语句。

```java
(String first , String second) -> {
    if (first.length() > second.length())
        return 1;
    else if (first.length() < second.length())
        return -1;
    return 0;
}
```

- 即使lambda表达式没有参数，也需要空括号，就像没有参数的方法。

```java
() -> {
    return 1;
}
```

- 如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。

```java
Comparator<String> cp = (first, second) ->first.length() - second.length();
//可以反推到first必定是String
```

- 如果方法只有一个参数，而且这个参数的类型可以推导得出，甚至可以省略圆括号。

```java
//
ActionListener ls = event -> System.out.println("");
```

- lambda的返回类型无需指定，因为可以由上下文推导出。
- **如果一个lambda表达式只在某些分支返回一个值，在其他分支不返回值，是不合法的。**

### 6.2.3 函数式接口

- lambda表达式与封装代码的接口是兼容的。
- 接口分为三类：
  - 普通的接口(`normal interface`)：接口中含有多个方法的
  - 函数式接口(`functional interface`)：接口中**只有一个抽象方法**
  - 标签式接口(`tagging interface`)：接口中没有方法的，比如`Serializable`

- 对于只有一个抽象方法的接口，需要这种接口的对象时，可以提供一个lambda表达式。这种接口称为函数式接口。
  - 比如`Comparator`接口。就只有一个抽象方法。
  - 需要一个比较器对象时，就可以提供一个`lambda`表达式来代替一个比较器对象，这个表达式就包含了`compare()`的具体实现
  - 把这个`lambda`表达式传递给其他函数，调用`compare()`时就会执行`lambda`表达式的体

```java
//
Arrays.sort(strings ,  (first, second) ->first.length() - second.length())
```

### 6.2.4 方法引用

- 只有当`lambda`表达式的体只调用一个方法而不做其他操作时，才能把`lambda`表达式重写为方法引用。

  - ```java
    () -> s.length() == 0;
    //不能重写为方法引用
    ```

- 可以在方法引用中使用`this`和`super`

- 用`::`运算符分隔方法名与对象或类名。

  - `object :: instanceMethod`：等价于向方法传递参数的`lambda`表达式

  - `Class :: instanceMethod`：第一个参数会成为方法的隐式参数

    - ```java
      String::compareToIgnoreCase();
      (String x, String y) -> x.compareToIgnoreCase(y);
      ```

  - `Class :: staticMethod`：所有参数都传递给静态方法

    - ```java
      Math :: pow
      (x, y) -> Math.pow(x, y);
      ```

      

### 6.2.5 构造器引用

```java
Class :: new;
```



## 6.3 内部类

### 6.3.1 使用内部类访问对象状态

- 内部类对同一个包中其他类隐藏。
- 内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据。
  - **一个内部类方法可以访问自身的数据字段，也可以访问创建它的外围类对象的数据字段。**
  - **内部类对象总有一个隐式引用指向创建它的外部类对象。**
- 内部类推荐声明为`private`。毕竟除了外围类，其他类也不需要去创建内部类对象。

### 6.3.2 内部类的特殊语法规则

- 表示外部类引用：`OuterClassName.this`
- 外围类的作用域之外引用内部类：`OuterClass.InnerClass`

### 6.3.3 内部类是否有用、必要、和安全

- 内部类只是一个`编译器现象`，与虚拟机无关。
  - 编译器会把内部类转换为常规类文件，用$分割外部类名与内部类名。`Outer$Inner.class`。
  - 内部类其实拥有更大的访问权限。

### 6.3.4 局部内部类

- **可以在一个方法中局部地定义一个类**
  - 声明局部类时不需要访问修饰符
  - 局部类的作用域被限定在声明这个局部类的块中。
  - 局部类对外界完全隐藏。

### 6.3.5 由外部方法访问变量

- 局部内部类还可以访问方法的局部变量
  - 可以访问外围方法的参数。
  - 局部变量必须是事实最终变量。
  - 实现的机制是在局部变量消失前复制为局部内部类的一个实例字段。

### 6.3.6 匿名内部类

- 不想看。

### 6.3.7 静态内部类

- 有时候使用内部类只是为了把一个类隐藏在另一个类的内部，而并不需要内部类有对外围类对象的引用。
  - 此时可以将内部类声明为`static`。
  - 声明为`static`的类不会生成那个引用。
- 只有内部类可以声明为`static`。
- **与常规内部类不同，静态内部类可以有静态字段和方法**
  - 常规内部类不能有静态方法和字段。
  - 随着类文件的加载所有静态成员都会在内存中获得相应的内存空间完成初始化，内部类可以视为外部类的类成员变量，如果这个内部类为非静态的话就是说他不会随着外部类的加载而得到内存分配，也就是说不会随着外部类的加载完成而完成初始化。如果此时内部类内存在静态成员的话，就会引起编译失败，原因很简单，内部类的静态成员此时也要完成初始化即要获得相应的内存空间，而他依托的非静态内部类又没有获得内存的分配，所以他就无法完成初始化。

## 6.4 服务加载器

## 6.5 代理





# 第7章 异常、断言和日志

- 在发生错误时，程序应该做到以下几点：
  - 向用户通知错误。
  - 保存所有的工作。
  - 允许用户妥善的退出程序。

## 7.1 处理错误

- 如果由于出现错误而使得某些操作没有完成，程序应该：
  - 返回到一种安全状态，并能够让用户执行其他的命令。
  - 允许用户保存所有工作的结果，并以妥善的方式终止程序。
- 异常处理的任务就是将控制权从产生错误的地方转移到能够处理这种情况的错误处理器。

- 需要考虑的异常：
  - 用户输入错误。除了键盘输入错误，还有格式错误巴拉巴拉巴拉。
  - 设备错误。打印机打印到一半没纸了，突然断网了。
  - 物理限制。磁盘满了
  - 代码错误。下标越界，查找不存在的记录，空指针。
- 如果某个方法不能采用正常途径完成它的任务，它会
  - 可以通过另外一个路径退出方法。
  - 不返回任何值，而是抛出一个封装了错误信息的对象。
  - 这个方法会立即退出，也不会从调用这个方法的地方的代码继续执行。
  - 由异常处理机制接手寻找对应的异常处理器。



### 7.1.1 异常分类

- 异常对象都是派生于`Throwable`类的。Java内置的异常类不能满足要求，可以创建自己的异常类。
- 所有异常都由`Throwable`继承而来，但在下一层次又分解为`Error`和`Exception`。
  - `Error`：Java运行时系统的内部错误和资源耗尽错误。你的应用程序不应该抛出这种类型的对象。这种错误出现，除了通知用户，并尽力妥善终止程序以外，几乎无能为力。
  - `Exception`：分解为两个分支。

- `Exception`：分解为`RuntimeException`和其他异常。
  - 由编程错误导致的异常属于`RuntimeException`。
  - 程序本身没问题而由`I/O`错误之类问题导致的属于其他异常。

- 派生于`RuntimeException`的异常：
  - 错误的强制类型转换。
  - 数组访问越界。
  - 访问`null`指针。

- 其他异常包括
  - 试图越过文件结尾继续读取数据。
  - 试图打开不存在的文件。
  - 试图查找一个类而这个类不存在。

- 派生于`Error`类和`RuntimeException`类的所有异常称为`非检查型(unchecked)`异常。所有其他称为检查型异常。
- **编译器将检查你是否为所有检查型异常提供了异常处理器。**

### 7.1.2 声明检查型异常

- 代码需要告知编译器可能会发生什么异常。
- 要在方法首部指明抛出什么异常。

```java
/*
*一个构造器
*/
public FileInputStream(String name) throws FileNotFoundException
```

- 自己编写方法时不必声明这个方法可能抛出的所有异常。以下情况会抛出异常。
  - 调用了一个抛出检查型异常的方法。
  - 检测到一个错误，并用`throw`语句抛出一个检查型异常。
  - 程序出现错误。可能是检查型异常也可能是非检查型异常？
  - Java虚拟机或运行时库出现内部错误。

- 前两种情况必须告知调用这个方法的程序员也可能抛出异常，否则如果没有处理器捕获这个异常，当前执行的线程就会终止。
- 处于公共类中的的方法，通过方法首部的异常规范(`Exception Specification`)声明这个方法可能抛出异常。
  - 一个方法可能抛出多个检查型异常，在方法首部全部列出，用逗号分割。

```java
public class e {
    public void load(String s) throws FileNotFoundException,EOFException
}
```

- **不需要声明Java内部的异常，也即继承自`Error`的异常。因为任何代码都可能抛出这类异常，我们对此异常也无法控制。**
- **不需要声明继承自`RuntimeException`的那些非检查型异常。因为这些错误完全可以在我们的控制之中。**

- **必须声明所有可能的检查型异常，而剩下的非检查型异常，要么我们无法控制(Error)，要么在一开始就应该避免。**
- 如果没有声明所有可能发生的检查型异常，编译器会发出错误消息。
- 还可以捕获异常，这样就不会从这个方法抛出异常，也就没必要用`throws`。

- **如果子类中覆盖了超类中的一个方法，那么子类中的方法声明的检查型异常不能比超类中声明的异常更通用。**
  - 子类方法可以抛出更特殊的异常。
  - 也可以根本不抛出任何异常。
  - 如果超类方法没有抛出任何检查型异常，子类也不能抛出任何检查型异常。

### 7.1.3 如何抛出异常

- 实例：读取文件，文件长度小于承诺长度。

```java
public String readData(Scanner in) throws EOFException
{
    while(...) {
        ......
            if(...) {
                throw new EOFException();
            }
    }
    return ...
}
```

- 如果已有的异常类可以满足要求，那么抛出这个异常很容易
  - 找到一个合适的异常类。
  - 创建一个这个类的对象。
  - 抛出这个对象。
- 一旦方法抛出异常，这个方法就不会返回调用者。不必操心建立一个默认返回值或错误码。

### 7.1.4 创建异常类

- 任何标准异常类都无法描述清楚的问题，创建自己的异常类来解决。
- 定义一个派生于`Exception`的类，或者派生于`Exception`的某个子类，如派生于`IOException`。
- 惯例如下
  - 两个构造器，一个默认无参数构造器，一个包含详细信息的构造器。
  - 超类`Throwable`的`toString`会获取异常对象的详细信息字符串。

```java
class FileFormatException extends IOException {
    public FileFormatException() {
        
    }
    public FileFormatException(String message) {
        super(message);
    }
}
public ReadFIle(Scanner in) throws FileFormatException {
    .......;
    throw new FileFormatException();
}
```

## 7.2 捕获异常

### 7.2.1 捕获异常

- 如果抛出一个异常，而没有在任何地方捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包括这个异常的类型和一个堆栈轨迹。
- 捕获异常需要设置，`try/catch`语句块。

```java
try {
    code....
}
catch (ExceptionType e) {
    code..
}
```

- 如果`try`语句块中的任何代码抛出了`catch`子句中指定的一个异常类。那么

  - 程序将跳过`try`语句块的其他代码。
  - 程序将执行`catch`语句中的处理器代码。

- 如果`try`语句块没有抛出任何异常，程序将跳过`catch`语句。

- **如果方法中的任何代码抛出了`catch`子句中没有声明的异常类型，那么这个方法就会立即退出。**

  ```java
  /**
  *一个例子，读取文件
  *read()可能会抛出IO异常
  */
  public void read(String filenname) {
      try {
          var in = new FileInputStream(filename);
          int b;
          while((b = in.read()) != -1) {
              .....;
          }
      }
      catch (IOException e) {
          e.printStackTrace();
      }
  }
  ```

- 如果选择什么也不做，不去捕获这个异常，而是将异常传递给调用者，那就必须声明这个方法可能会抛出一个`IOException`。

```java
/**
*read(String filename)可能会抛出IO异常
*这个IO异常是你不知道如何处理的，你决定交给调用read(String filename)的人去处理
*将抛出的异常继续传递下去，传递给调用者。
*/
public void read(String filenname) throws IOException
{

        var in = new FileInputStream(filename);
        int b;
        while((b = in.read()) != -1) {
            .....;
        }
}
```

- 如果调用了一个抛出检查型异常的方法，就必须处理这个异常，或者选择继续传递这个异常。
  - 捕获你知道如何处理的异常，继续传播那些你不知道如何处理的异常。
  - 想传播一个异常，必须在方法首部添加`throws`说明符，提醒调用者这个方法可能抛出一个异常。
  - 查看API文档得知API可能抛出的异常。然后再决定是直接处理还是继续传递。

- **如果编写的方法覆盖了超类的一个方法，而这个超类方法没有抛出异常，所以你也不能抛出异常，所以你就必须捕获你的方法代码中出现的每一个检查型异常。**
- 不允许在子类方法的`throws`说明符中出现超类方法未列出的异常。



### 7.2.2 捕获多个异常

- 一个`try`语句块可以捕获多个异常类型，并对不同类型的异常做不同处理。要为每个异常类型使用一个单独的`catch`子句。

```java
try {
    .......
}
catch (FileNotFoundException f) {
    .....;
}
catch (UnkonwnHostException u) {
    .....;
}
catch (....) {
    .....;
}
```

- 异常对象可能包含有关异常性质的信息，尝试使用`e.getMessage()`
- `e.getClass.getName()`得到异常的实际类型。
- Java7后同一个`catch`可以捕获多个异常类型。
  - 假如处理两个不同异常的动作是一样的，那么可以合并`catch`语句。
  - 只有当捕获的异常类型彼此之间不存在子类关系时可以使用。
  - 捕获多个异常时，异常变量`f`隐含为`final`。

```java
try {
    .......
}
catch (FileNotFoundException f | UnkonwnHostException u) {
    .....;
}

```

### 7.2.3 再次抛出异常与异常链

- 可以在`catch`字句中抛出一个异常。通常希望改变异常的类型时会这样做。

```java
/**
*例子
*指示子系统故障
*SeverletException
*/
try {
    ....;//访问数据库
}
catch (SQLException e) {
    throw new SeverletException("Database Error :" + e.getMessage() );
}
```

- 一种更好的处理方法，不会丢失原始异常的细节。
  - 将捕获的异常作为抛出的异常的原因。

```java
try {
    .....;//访问数据库
}
catch (SQLException original) {
    var e = new SeverletException("Database Error");
    e.initCause(original);
    throw e;
}
/**
*可以使用下列语句来获取原始异常
*/
Throwable oringal = caughtException.getCause();
```

- 这种方法可以将检查型异常包装成运行时异常，在不允许抛出检查型异常的方法中间接抛出。

- 也可以捕获一个异常并记录之后直接抛出。

```java
public void update() throws SQLException {
    try {
        .....;//访问数据库
    }
/**
*编译器会查看throw语句，发现这里抛出的是Exception，但是声明函数抛出的是SQLException
*于是编译器会往上查看对应的try语句。、
*如果try块中抛出的异常确实只有SQLException，并且在catch语句中被捕获的异常没有被改变
*将外围方法声明为抛出SQLException就是合法的
*/
   catch (Exception e) { 
        logger.log(lever,message,e);
        throw e;
    }
}
```

### 7.2.4 finally 子句

- `finally`子句存在的意义：
  - 代码抛出一个异常时，就会停止处理这个方法中剩余的代码，并退出这个方法。如果这个方法已经获得了一些只有它自己知道的本地资源，而且这些资源必须清理，那就会存在没办法清理的问题。
  - `finally`可以解决这个问题。
- **不管是否有异常被捕获**，**所有情况下`finally`子句中的代码都会被执行。**
  - `try`语句可以没有`catch`子句，只有`finally`子句。
  - `finally`语句会在抛出未被捕获的异常之前执行。
  - `finally`语句会在捕获异常之后执行。
  - **总之就是，不管什么情况，一定会执行`finally`中的语句**
- `try`可以没有`catch`而只有`finally`
- **不要把改变控制流的语句(`return throw break continue`)放入`finally`子句中，会造成意想不到的后果，比如返回值遮蔽。**

### 7.2.5 try-with-Resources 语句

- 看书就完事了。跟看文档一样。

### 7.2.6 分析堆栈轨迹元素

- 堆栈轨迹：程序执行过程中某个特定点上所有挂起的方法调用的一个列表。
- 当`Java`因为一个未捕获的异常而终止时，就会显示堆栈轨迹。
- 可以调用`Throwable`类的`printStackTrace()`打印堆栈轨迹。

## 7.3 使用异常的技巧

- 只在异常情况下使用异常，不要把异常作为简单测试的手段。
- 不要过分细化异常。
- 充分利用异常层次结构。
- 不要压制异常。
- 检测错误时宜严不宜宽。
- 大胆传递异常。

## 7.4 使用断言

- 我觉得JUnit挺好的。看文档的事。

### 7.4.1 断言的概念

- 断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。
- 关键字`assert`：
  - `assert condition;`
  - `assert condition : expression;`
  - 这两个语句都会计算条件，如果结果为false，抛出`AssertionError`异常。第二个语句还会把表达式传入异常对象构造器并转换成一个消息字符串。
  - 表达式部分的唯一目的就是产生一个消息字符串。



### 7.4.2 启用和禁用断言

### 7.4.3 使用断言完成参数检查

## 7.5 日志

- 以后看吧。

# 第8章 泛型程序设计

- 泛型类和泛型方法有类型参数，这使得它们可以准确地描述用特定类型实例化时会发生什么。

## 8.1 为什么要使用泛型设计

### 8.1.1 类型参数的好处

- 使用Object来编写泛型程序的时候，没有办法做类型检查。
  - 比如向一个存满了String的Object数组中放非String类型。
  - 这段代码本身可以通过编译，但是运行的时候会在别的地方出错，比如要获取一个String的时候，给了一个其他类型。

- 获取值的时候，使用类型参数的时候不需要进行强制类型转换，而使用Object编写泛型的时候需要强制类型转换。



### 8.1.2 谁想成为泛型程序员

## 8.2 定义简单泛型类

- 泛型类就是具有一个或多个类型变量的类。
- 本章使用`Pair`类作为例子。

```java
public class Pair<T> {
    private T first;
    private T second;
    public Pair() {
        first = null;
        second = null;
    }
    public Pair(T first , T second) {
        this.first = first;
        this.second = second;
    }
    public T getFirst() {
        return first;
    }
    public T getSecond() {
        return second;
    }
    public void setFirst(T value) {
        first = value;
    }
    public void setSecond(T value) {
        second = value;
    }
}
```

- 泛型类可以有多个类型变量，放在尖括号内，逗号分割。
  - 类型变量在整个类定义中用于指定`方法的返回类型`以及`字段`和`局部变量`的类型。

```java
public class Pair<T,U> {
    .....;
}
```

- 用具体类型来替换类型变量来实例化类。

## 8.3 泛型方法

- **泛型方法可以在普通类中定义。**也可以在泛型类中定义。
- 类型变量放在修饰符后面，返回类型前面
- 调用泛型方法时，把具体类型放在尖括号中，方法名前面。

```java
public class e {
    public static <T> T getMiddle(T... a) {
        ...;
    }
    String str = e.<String>getMiddle("AAA","BBB","CCCCC");
}
```

- 大多数情况下前一条的具体类型可以省略，编译器可以通过提供的参数与泛型类型匹配来推断。

```java
    String str = e.getMiddle("AAA","BBB","CCCCC");
```

- 一个不能推断的情况。需要解析编译器错误来确定。

```java
/**
*编译器解释这个代码的参数有两种方式
*将参数装箱为Double和Integer对象后，
*一种是解释为Number的子类e.getMiddle(Number... a)
*一种是解释为Comparable的子类e.getMiddle(Comparable... a)
*/
double middle = e.getMiddle(-1,0,3.14)
/**
*补救的方式是消除歧义
*将所有数都写成double
*/
```

## 8.4 类型变量的限定

- 有时候需要对类型变量做一些限定

- 比如在求一组对象的最小者，使用泛型时必须限定传入的对象是实现了`Comparable`的

```java
/**
*这里存在的问题是我们无法保证T一定实现了compareTo()方法
*所以解决的方法是限定T只能是实现了Comparable接口的类
*/
class e {
    //假设a不会为null
    public static<T> T min(T[] a) {
        T smallest = a[0];
        for (int i = 0 ; i < a.length() ; i ++) {
            if (smallest.compareTo(a[i]) > 0) {
                smallest = a[i];
            }
        }
    }
}
/**
*添加对T的限定之后
*现在min方法就只能限定在实现了Comparable接口的类上
*/
    public static<T extends Comparable> T min(T[] a) {
        ...;
    }
```

- `T`和限定类型可以是接口也可以是类。
- `T`应该是限定类型的子类型。
- **一个类型变量或通配符可以有多个限定。**
- 限定类型用`&`分割，类型变量用逗号分割。
- 可以有多个接口作为超类型，但是最多只有一个类作为限定。如果一个类作为限定，它必须是限定列表中的第一个限定。

```java
<T extends BoundType>
<T extends Comparable & Serializable>
```

## 8.5 泛型代码和虚拟机

- **虚拟机中没有泛型类型对象，所有对象都属于普通类，**

### 8.5.1 类型擦除

- 无论何时定义一个泛型类型，都会自动提供一个相应的原始类型。这个原始类型的名字就是去掉类型参数之后的泛型类型名。

- **类型变量会被擦除**并替换为其限定类型，无限定的变量则替换为`Object`。
- 原始类型用**第一个限定**来替换类型变量，如果没有显式给定限定类型，就替换为`Object`。
- **应该将标签接口（即没有方法的接口，如可序列化）放在限定列表的最后，这样可以提高效率。**

```java
/**
*未给定限定类型
*Pair<T>类
*原始类型
*不同类型的Pair类型擦除后都会变成原始类型的Pair
*/
public class Pair {
    private Object first;
    private Object second;
    public Pair() {
        first = null;
        second = null;
    }
    public Pair(Object first , Object second) {
        this.first = first;
        this.second = second;
    }
    public Object getFirst() {
        return first;
    }
    public Object getSecond() {
        return second;
    }
    public void setFirst(Object value) {
        first = value;
    }
    public void setSecond(Object value) {
        second = value;
    }
}
```

- 给定限定类型的`Pair`

```java
public class Pair<T extends  Comparable & Serializable> implements Serializable {
    private T first;
    private T second;
    public Pair() {
        first = null;
        second = null;
    }
    public Pair(T first , T second) {
        this.first = first;
        this.second = second;
    }
}
/**
*原始类型
*可以发现各处的T都被替换成了第一个限定Comparable
*/
public class Pair implements Serializable {
    private Comparable first;
    private Comparable second;
    public Pair() {
        first = null;
        second = null;
    }
    public Pair(Comparable first , Comparable second) {
        this.first = first;
        this.second = second;
    }
}
```

### 8.5.2 转换泛型表达式

- 编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。
  - 比如类型参数没有任何限定，被擦除为`Object`的情况下。
  - 编译器会将`Object`类型的返回值强制转换为对应的类型。 

- 访问一个泛型字段时也会插入强制类型转换。



### 8.5.3 转换泛型方法

- 类型擦除也存在于泛型方法中。

```java
/**
*类型擦除前
*/
public static <T extends Comparable> T min(T[] a)
/**
*类型擦除后
*/
public static  Comparable min(Comparable[] a)

```

- 所有的类型参数都会替换为它们的限定类型。
- 会合成桥方法来保持多态。
- **一个方法覆盖另一个方法时，可以指定一个更严格的返回类型，这是合法的。**

### 8.5.4 调用遗留代码

- 在有把握编译器发出警告的代码是正确的情况下，使用注解关闭代码检查


## 8.6 限制与局限性

- 大多数限制都是由类型擦除引起的。

### 8.6.1 不能用基本类型实例化类型参数

- 不能使用基本类型来代替类型参数。
  - 原因是类型擦除，被擦除后的原始类含有`Object`，而`Object`不能存储基本类型。
  - 但是有包装器。
  - 基本类型只有八种，可以用单独的类和方法来处理，并不是一个很大的缺陷。


### 8.6.2 运行时类型查询只适用于原始类型

- 虚拟机中的对象总有一个特定的非泛型类型。因此所有的类型查询只产生原始类型。
- 试图查询一个对象是否属于某个泛型类型时，会得到编译器错误或警告。

```java
/**下列仅仅测试a是否是一个任意类型的Pair
*等价于 if (a instanceof Pair<Object>)
*而不是测试a是否是T类型的Pair
*/
if (a instanceof Pair<T>) // 
if (a instanceof Pair<String>) 
Pair<String> p = (Pari<String>)a;
```

- `getClass()`也总是返回原始类型。

  - 返回的类型都是擦除之后，不带任何类型参数的。

  ```java
  Pair<String>.getClass().equals(Pair<Integer>).getClass()); //返回值是true，因为getClass()返回的是Pair.class
  ```

  

### 8.6.3 不能创建参数化类型的数组

- 不能实例化参数化类型的数组
  - 因为类型擦除之后，这个数组实际上是`Object[]`。
  - 会导致数组的类型检查失效。


```java
/**
*Error
*/
var table = new Pair<String>[100];
/**
*声明类型为Pair<String>类型的变量还是合法的
*只是不能对它用new
*/
Pair<String>[] table;
```

### 8.6.4 Varargs 警告

- 向参数可变的方法中传递一个泛型类型的实例。

### 8.6.5 不能实例化类型变量

```java
/**
*不能new T
*/
new T;
//相当于
    new Object;
```



## 8.8通配符类型

### 8.8.1 通配符概念

- 通配符类型中，类型参数允许发生变化。

```java
//表示类型参数是Employee的任何子类
Pair<? extends Employee>
Pair<Manager> //为Pair<? extends Employee>的子类型
Pair<Manager> PM = new Pair<Manager>(ceo, cfo);
Pair<? extends Employee> PE = PM // 可以，因为右边是左边的子类
```

- 使用通配符来做子类限定，不能将通配符作为函数的参数，但是可以作为返回值

  - 作为参数没办法进行匹配，只知道需要的是子类型，但是不知道需要具体的哪一个类型。

- ```java
  public ? extends Employee getFirst();//可以
  public void setFirst(?extends Employee )//不可以
  ```

### 8.8.2 通配符的超类型限定

- 可以为方法提供参数，但是不能作为返回值。

```java
? super Manager;//限定为Manager的所有超类型
```

### 8.8.3 无限定通配符

```java
Pair<?> //有如下方法
    ? getFirst() //返回值只能被赋给一个Object
    void setFirst(?) //不能被调用，Object也调用不了
```

- 可以用任意的`Object`对象调用原始`Pair`类的方法

### 8.3.4 通配符捕获

- 通配符不是类型变量，不能将`?`作为一种类型。

# 第9章 集合

- 仅介绍如何使用标准库中的集合

## 9.1 Java集合框架

### 9.1.1 集合接口与实现分离

- Java集合类库将接口与实现分离。
- **只有在构造具体的集合对象时才会使用具体的类，但是可以使用接口类型的变量存放集合引用**



### 9.1.2 Collection接口

- `Collection`接口最基本的两个方法

```java
public interface Collection<E> {
    /*
    *返回true，如果添加元素成功
    *返回false，如果集合没有发生变化
    */
    boolean add(E element);
    /*
    *返回一个实现了Iterator接口的对象
    *可以使用这个对象依次房屋为集合的元素
    */
    Iterator<E> iterator();
}
```

### 9.1.3 迭代器

- 迭代器`Iterator`接口包含以下4个方法。

```java
public interface Iterator<E> {
    /*
    *反复调用next()可以逐个访问集合中的元素
    *如果到达集合末尾则返回NoSuchElementException
    *在调用它之前先调用hasNext()
    *在hasNext()返回true的情况下反复调用它
    */
    E next();
    /*
    *调用next()之前调用hasNext()
    *如果还没到达集合末尾，返回true
    *反之返回false
    */
    /**
    *删除上次调用next()时返回的元素
    *越过next()直接调用remove()是不合法的
    *抛出异常
    */
    void remove();
    default void forEachRemaining(Comsumer<? super E> action);
}
```

- `for-each`循环
  - 编译器将`for-each`循环转化为带有迭代器的循环。

```java
Collection c = .....;
Iterator<String> e = c.iterator()
while(e.hasNext()) {
    String str = e.next();
    .......;
}
/**
*for-each
*/
for(String str : c) {
    .....;
}
```

- `for-each`循环可以处理任何实现了`Iterable`接口的类。

```java
public interface Iterable<E> {
    /*
    *返回一个迭代器
    */
    Iterator<E> iterator();
}
```

- `Collection`接口扩展了`Iterable`接口。标准库中任意集合可以使用`for-each`。

### 9.1.4 泛型实用方法

- `Collection`接口提供了许多许多有用的方法。
  - 实现这个接口原则上要把每一个方法都实现。但是这样很烦。
  - 所以Java提供了抽象集合类`AbstractCollection`。
    - 保留基础方法`size()`和`iterator()`为抽象方法。
    - 但为实现者实现了其他的例行方法。
  - 具体集合类可以扩展`AbstractCollection`类，只需要提供抽象方法的具体实现即可。
  - 也可以去覆盖超类提供的例行方法，如果更高效。

## 9.2 集合框架中的接口

- 集合的两个基本接口：`Collection`和`Map`。

```java
/**
*映射加入键/值对的方法
*/
void put(K key , V value);
/**
*从映射中读取值
*/
V get(K key);
```

- `List`：
  - 有序集合。元素会增加到容器的特定位置。
  - 迭代器访问：顺序地访问。
  - 整数索引访问：随机访问。

## 9.3 具体集合

### 9.3.1 链表

### 9.3.1 数组列表

### 9.3.3 散列表

- 标准库使用的桶数是2的幂。默认值为16。
- 装填因子默认值为0.75。

### 9.3.4 树集

## 9.4 映射

### 9.4.1 基本映射操作

- 映射是将值映射到键。
- 要想检索一个对象，**必须使用键**。
- 键必须是唯一的，不能对同一个键存放两个值。





# 第12章 并发

- 常用方法集合：

  - ```java
    public class Thread {
        static void Sleep(long millis); //休眠指定毫秒数，静态方法
        static void yield(); //使当前正在运行的线程主动让出CPU，静态方法
        void join();//使当前正在运行的线程等待调用这个Join方法的线程对象执行完毕，此时当前正在运行的线程会陷入等待状态
        static Thread currentThread()//获得当前正在运行的线程对象
    }
    ```

    

- 并发执行的进程数目并不受限于CPU的数目。
- 多线程程序在更低一层扩展了多任务的概念：单个程序看起来在同时完成多个任务。每个任务在一个线程中执行。
- 线程共享数据，而每个进程都有自己一整套的变量。
- 线程间通信比进程间通信开销小。

## 12.1 什么是线程

- **不要直接调用`run()` 方法，这并不会创建一个线程来运行这个方法，而是就在调用`run()`方法的线程运行**

- 在单独的一个线程中运行任务的简单过程：
  1. 建立一个类，这个类要实现`Runnable`接口，或者使用`lambda`表达式
  2. 将这个`Runnable`传递给一个`Thread`对象。通过这个`Thread`对象调用它的`start()` 方法来启动线程。
  3. **不要调用`Thread`类或`Runnable`类的`run()`方法**，这样是只会在同一个线程中执行这个任务，不会启动新的线程。
- 第二种方法：

  - 建立一个类，这个类扩展`Thread`，作为`Thread`的子类
  - 在这个类中实现`run()`。
  - 利用这个类的对象调用`start()`

- 简单总结一下创建线程的两种办法：

  - 方法一：

    - 使用`Runnable`接口，这里又包含两种选择：

      1. 使用`Lambda`表达式
      2. 使用一个实现了`Runnable`接口的类

    - 传递给`Thread`类的一个实例对象一个`Runnable`对象，这个对象可以是1，也可以是实现`Runnable`接口的类的实例。

    - 调用`Thread`类的实例方法`start()`，这个方法会启动一个线程来运行`Runnable`接口的`run()`方法

    - ```java
      public class MyRunnable implements Runnable{
          private int ID;
          @Override
          public void run() {
              try {
                  for (int i = 0; i < 100; i ++) {
                      System.out.println("Thread " + ID +"  "+ i);
                      System.out.println();
                      Thread.sleep(1000);
                  }
              } catch (InterruptedException e) {
                  throw new RuntimeException(e);
              }
          }
      
          public MyRunnable(int ID) {
              this.ID = ID;
          }
      
          public static void main(String[] args) {
              MyRunnable myRunnable1 = new MyRunnable(1);
              MyRunnable myRunnable2 = new MyRunnable(2);
              MyRunnable myRunnable3 = new MyRunnable(3);
              Runnable MyThread4 = () -> {
                  try {
                      for (int i = 0; i < 100; i ++) {
                          System.out.println("Thread " + 4 +"  "+ i);
                          System.out.println();
                          Thread.sleep(1000);
                      }
                  } catch (InterruptedException e) {
                      throw new RuntimeException(e);
                  }
              };
              Thread thread1 = new Thread(myRunnable1);
              Thread thread2 = new Thread(myRunnable2);
              Thread thread3 = new Thread(myRunnable3);
              Thread thread4 = new Thread(MyThread4);
              thread1.start();
              thread2.start();
              thread3.start();
              thread4.start();
      
          }
      }
      ```

  - 方法二：

    - 扩展(`extends`)`Thread`类，将自己的类扩展为`Thread`类的一个子类。

    - 覆盖掉`Thread`类的`run()`方法，然后构造一个子类的对象，调用子类的`start()`方法。

    - ```java
      public class MyThread extends Thread{
          private int ID;
          public MyThread(int ID) {
              this.ID = ID;
          }
          @Override
          public void run() {
              try {
                  for (int i = 0; i < 200; i ++) {
                      System.out.println("Thread " + ID +"  "+ i);
                      System.out.println();
                      Thread.sleep(10);
                  }
              } catch (InterruptedException e) {
                  throw new RuntimeException(e);
              }
          }
      
          public static void main(String[] args) {
              MyThread myThread1 = new MyThread(1);
              MyThread myThread2 = new MyThread(2);
              MyThread myThread3 = new MyThread(3);
              MyThread myThread4 = new MyThread(4);
              myThread1.start();
              myThread2.start();
              myThread3.start();
              myThread4.start();
          }
      }
      
      ```

      





## 12.2 线程状态

- 线程的六种状态：使用`getState()`方法得到
  - New（新建）
  - Runnable（可运行）
  - Blocked（阻塞）
  - Waiting（等待）
  - Timed Waiting（计时等待）
  - Terminated（终止）

### 12.2.1 新建线程

- 当使用`new`操作符创建一个新线程时，这个线程还没有开始运行。它的状态是新建。
- 处于新建状态的线程，程序还没有开始运行线程中的代码。
- 在线程运行之前还有一些基础工作要做。比如分配内存资源？



### 12.2.2 可运行线程

- 一旦调用`ThreadObject.start()`方法，线程就处于可运行状态。
- **任何给定时刻，处于可运行状态的线程，可能正在运行，也可能没有运行。要由操作系统为线程提供时间片。**
- 一旦一个线程开始运行，它不一定始终保持运行。线程调度的细节依赖于操作系统提供的服务。
- 运行中的线程有时需要暂停下来，让其他线程有机会运行。
- 抢占式调度系统给每个线程一个时间片来执行任务，时间片用完，操作系统就剥夺该线程的运行权并分配给其他线程。
- 在有多个处理器的机器上，线程数目小于处理器数目时（否则还是要分配时间片），多个线程可以并行运行，每个处理器运行一个线程。



### 12.2.3 阻塞和等待线程

- 处于阻塞和等待状态的线程，不运行任何代码，消耗最少的资源。要由线程调度器来重新激活这个线程。
- 当一个线程试图获取一个内部的对象锁，而这个对象锁目前被其他线程占有，该线程就会被阻塞。当所有其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，该线程变成非阻塞状态。
- 当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。
- 调用有超时参数的方法时，线程进入计时等待状态，这一状态一直保持到超时或者接收到适当通知。



### 12.2.4 终止线程

- `run()`方法正常退出，线程自然终止。
- 因为一个没有捕获的异常终止了`run()`方法，使线程意外终止。

### 关于Join()

- `Join()`方法由一个`Thread`对象调用，谁调用`Join()`方法，就是要等待谁。字面来看，`Join()`是加入的意思，谁调用就等待谁的加入。

- 比如要让`Thread1`等待`Thread2`，那么就在`Thread1`中`thread2.join();`

  - 在`Thread1`等待`Thread2`的加入的时候，`Thread1` 是处于等待状态的（阻塞状态）。

- ```java
  public class JoinDemo {
      public static void main(String[] args) {
          //第一个线程
          Runnable th1 = () -> {
              try {
                  for (int i = 0; i < 10; i++) {
                      System.out.println("Thread 1" + " " + i);
                      Thread.sleep(100);
                  }
              } catch (InterruptedException e) {
                  throw new RuntimeException(e);
              }
          };
          Thread thread1 = new Thread(th1);
          
          //第二个线程，在这个线程中调用了Thread1.join()来等待第一个线程完成其任务
          Runnable th2 = () -> {
              try {
                  System.out.println("Thread2 wait for thread1: ");
                  thread1.join();
                  System.out.println("Thread1 Finished\n\n");
                  for (int i = 0; i < 10; i++) {
                      System.out.println("Thread 2" + " " + i);
                      Thread.sleep(100);
                  }
              } catch (InterruptedException e) {
                  throw new RuntimeException(e);
              }
          };
          Thread thread2 = new Thread(th2);
          System.out.println("Main waiting thread2");
          thread1.start();//主线程中创建线程1
          thread2.start();//主线程中创建线程2
          //主线程等待线程2
          try {
              thread2.join();
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
          System.out.println("Thread 2 Finished");
      }
  }
  ```

  上面代码的输出：可以看到主线程等待线程2运行结束，线程2等待线程1运行结束，因此线程1运行完==>线程2运行完==>主线程运行完

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209291835392.png" alt="image-20220929183458943" style="zoom: 67%;" />



## 12.3 线程属性

### 12.3.1 中断线程

- 没看太懂

### 12.3.2 守护线程

- 当只剩下守护线程时，虚拟机将退出。因为守护线程的唯一用途是给其他线程提供服务，所以如果只剩下它，就没必要继续运行程序了。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209291908432.png" alt="image-20220929190802121" style="zoom:67%;" />

### 12.3.3 线程名

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209291909052.png" alt="image-20220929190937774" style="zoom:80%;" />

### 12.3.5 线程优先级

- Java为线程定义了十个优先级，一到十，常规的优先级为5。
- 线程的调度还是高度依赖于OS的调度器的。但是优先级高的线程更可能被优先选择。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209291911772.png" alt="image-20220929191108448" style="zoom: 80%;" />

## 12.4 同步

- 使用可重入锁来保证同步：

- ```java
  
  public class bank {
      private ReentrantLock bankLock = new ReentrantLock();
      public void Transfer() {
          bankLock.lock();
          try {
              ....codes// 临界区代码放这里
          } finally {
              bankLock.unlock();//解锁放这里，保证无论如何都会解锁
          }
      }
  }
  
  ```

### 条件对象

- 条件对象和锁共同搭配使用，可以做到线程拿到锁又发现不满足继续干活的条件于是自动放弃锁的目的。
- 直接看原文吧
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292001056.png" alt="image-20220929200059701" style="zoom:80%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292001230.png" alt="image-20220929200154925" style="zoom:80%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292003862.png" alt="image-20220929200302401" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209291957497.png" alt="image-20220929195707088" style="zoom:67%;" />

![image-20220929200321283](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292003604.png)

### synchronized关键字

- 每个对象都有一个内部锁，这个内部锁也有一个内部条件对象.
  - 在使用这个内部条件对象时，调用`wait()`相当于调用常规条件对象的`await()`，用于不满足条件时放弃锁以及等待。
  - 调用`notifyAll()`相当于调用常规条件对象的`signalAll()`，用于可能满足条件时唤醒等待中的线程。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292015431.png" alt="image-20220929201523151" style="zoom: 80%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292022530.png" alt="image-20220929202225208" style="zoom: 80%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292025457.png" alt="image-20220929202514178" style="zoom: 80%;" />

- 可以将静态方法也声明为同步的：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292029267.png" alt="image-20220929202934983"  />

- 一些关于锁＋条件对象，以及`synchronized`关键字的
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202209292030222.png" alt="image-20220929203038911" style="zoom:80%;" />

# 卷二

# 第2章 输入与输出

## 输入流

## 输出流
