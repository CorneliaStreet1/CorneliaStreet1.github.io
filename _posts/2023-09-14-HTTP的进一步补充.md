### HTTP/0.9：初具雏形

HTTP 0.9又被称作单行（银行的行，One-Line）协议。

因为它的请求报文只有一行——以唯一可用的GET方法开头，后跟目标资源的路径。

比如：

```http
GET /index.html
```

因为请求只有一行内容，所以被叫做单行协议。



HTTP 0.9的响应也很简单，**就只有HTML文档本身**，没有HTTP头部。

没有头部意味着：

- 没有类型字段，也就意味着只能传输HTML文档。
- 没有错误代码或者是状态码，一旦出错就只能响应一个HTML文档，文档里描述错误信息，供人查看。



特性：

- 响应只有HTML文档，**没有HTTP头部**
- 文档传输完成后，TCP连接终止。



缺陷：

- 因为没有头部，无法携带元数据，所以：
  1. 缺少状态码或者错误码，使得浏览器无法得知错误原因从而调整自身行为。
  2. 缺少类型字段，如Content-Type、Content-Length等。使得它无法识别并解析其他类型的响应内容。没有类型字段就意味着类型只能单一固定——HTML
  3. 只能传输HTML
- 只支持GET请求，没有POST，DELETE，PUT等方法。
- 明文传输，安全性问题。
- 只能传输ASCII字符的文本数据

### HTTP /1.0：一个没有成为标准的协议

更好地定义了HTTP请求和响应的结构，加入了许多头部信息，因而可以处理其他格式的响应内容，比如视频、图像等。

添加了两个方法：POST和HEAD。

添加了状态码，引入了字符集、类型、授权、缓存、内容编码等内容。

下面的请求头部：\

- GET方法，目标路径是`/`，也即根目录，协议版本是HTTP/1.0

- Host：用于指定请求的主机名
- User-Agent：用户浏览器的代理。
- Accept：HTTP请求头部字段，指示客户端可以接受任何类型的响应内容，通配符 `*` 表示接受所有类型的内容。

```http
GET / HTTP/1.0
Host: cs.fyi
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```



响应报文示例：头部与Body部分空出一行作为分割。

```http
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

(response body)
(connection closed)
```

虽然请求和响应标头仍保留为 ASCII 编码，但**响应正文可以是任何类型**，即图像、视频、HTML、纯文本或任何其他内容类型。因此，现在服务器不仅仅只能向客户端发送HTML文档，还可以发送其他任何内容类型。

所以超文本传输协议的“超文本”其实是不太恰当的用词。



额外提两个东西：URL编码和Base64编码

URL编码：用于处理URL中带有非ASCII字符的编码。举个例子，我们想访问的URL里，目标资源的路径是带有中文的，但是HTTP请求的头部都是ASCII字符的，那么我们如何把中文转换为ASCII字符，从而在URL里传输？

> **URL编码：** URL 编码是一种将特殊字符和非 ASCII 字符转换为 ASCII 字符的方法，使它们能够在 HTTP 请求的 URL 中进行传输。具体而言，URL 编码使用 "%" 符号后跟两个十六进制数字来表示一个字符。例如，中文字符 "中" 的 URL 编码表示为 "%E4%B8%AD"。这个编码表示了字符 "中" 在 ASCII 字符集中的十六进制表示。当 HTTP/1.0 的请求或响应中包含中文字符时，这些字符会被转换成对应的 URL 编码形式。服务器收到 URL 编码后的请求后，会将其还原为原始的中文字符进行处理。需要注意的是，HTTP/1.0 的 URL 编码仅适用于 URL 中的字符编码。

比如下图的这个网址，其实如果从Chrome地址栏复制下来，是：

```html
https://www.asmrgay.com/asmr/%E4%B8%AD%E6%96%87%E9%9F%B3%E5%A3%B0
```

<img src="https://i.imgur.com/vKwYTDB.png" alt="image-20230910012601164" style="zoom: 80%;" />

另外一个就是利用Base64编码在ASCII上传输任何内容。



HTTP1.0的特性：

- 定义了HTTP请求和响应报文的格式：起始行 + 头部信息 + 空行 + 消息体
- 在起始行加入了状态码和响应的状态描述
- 加入了内容协商：虽然HTTP头部仍然是ASCII字符构成的，但是通过头部的Content-Type、Content-Length、Transfer-Encoding等头部属性，可以做到在消息体中传输不同类型的内容。
- **可以传输任何类型的文件**
- **不再是只能传输英文文本数据**。
- **新增POST、HEAD请求：** POST请求方法允许客户端向服务器提交数据，而HEAD请求方法允许客户端获取资源的元数据。

重点特性：

- **初步引入缓存概念：** HTTP/1.0引入了头部字段如Expires和Last-Modified，用于控制缓存的行为，以及头部字段如If-Modified-Since和If-None-Match，用于条件性请求。
- **初步引入持久链接：** HTTP/1.0引入一个名为 Connection: keep-alive 的新标头，来保持请求建立起来的TCP连接，以供后续请求继续使用该链接完成请求。
- **初步引入代理支持：** HTTP/1.0引入了Proxy-Connection头部字段来指示代理服务器是否应保持持久连接，并引入了Via头部字段，用于标识请求经过的代理服务器链

缺陷：

- **持久链接未得到广泛支持，默认仍为短连接**。
- **请求阻塞：** 在HTTP/1.0中，每个请求都需要按照顺序进行，即必须等待前一个请求的响应返回后才能发送下一个请求。如果前一个请求很耗时，会导致后续请求被阻塞，影响并发性能。
- **无状态**：HTTP是无状态协议
- **缺乏压缩支持：** HTTP/1.0没有内置的数据压缩机制，因此在传输大量文本数据时，没有有效地压缩数据，增加了网络传输的开销。
- 因为不是官方标准，所以许多浏览器厂商并没有按照HTTP/1.0的指导实现HTTP，导致在实际运用中混乱不堪。

### HTTP /1.1：第一个成为标准的HTTP协议

在请求/响应格式上HTTP/1.1与HTTP/1.0并无差异，因为HTTP/1.1沿用了HTTP/1.0的请求/响应格式。

随便抓的一个HTTP1.1的包：

<img src="https://i.imgur.com/2Kh6hgD.png" alt="image-20230910170919849" style="zoom: 67%;" />



特性：

- **默认启用持久化连接**：HTTP/1.1中连接默认情况下不会关闭，而是保持打开状态，从而允许多个**顺序请求**。
  - 如果想关闭连接：要关闭连接，在头部加上`Connection: close` 。客户端通常在最后一个请求中发送此标头以安全地关闭连接。
- **管道化技术：（流水线技术）**： 客户端可以在同一连接上向服务器发送多个请求，而无需等待服务器的响应，并且**服务器必须按照接收请求的顺序发送响应**（也就是说，服务器收到的是请求1,2,3,4,5,6的话，也必须按照这个顺序发送响应）。
- 新增Cookie：抓过包看过的话，会知道Cookie其实就是头部的一个字段，其内容是一个Key-Value的形式。或者说名字-值的形式。

<img src="https://i.imgur.com/jdBdbRl.png" alt="image-20230910152750901" style="zoom:80%;" />



重点的特性：我之前不了解的

- **增强内容协商机制：** HTTP/1.1增加了Accept-Language、Accept-Encoding和Accept-Charset等头字段，允许客户端明确指定其首选语言、内容编码方式和字符集，让服务器能够更好地提供适配客户端需求的内容。

- **新增Gzip、Deflate等压缩技术**：在HTTP/1.1中，服务器可以使用Gzip、Deflate等压缩算法来压缩HTTP响应的实体主体部分（如HTML、CSS、JavaScript等），然后在响应头中使用"Content-Encoding"字段来指示客户端该响应已经被压缩以及压缩的算法。客户端收到压缩的响应后，会自动解压缩以获取原始内容。
  - 也就是说，头部字段`Content-Encoding`其实是在指示使用的压缩编码。
  - 也有一个`Accept-Encoding`头部字段，表明客户端可以接收的压缩算法。

<img src="https://i.imgur.com/s2BqssE.png" alt="image-20230910153226525" style="zoom:80%;" />

- **引入了基本认证和摘要认证机制**。
- **引入了范围请求和部分响应机制：** HTTP/1.1引入了范围请求和部分响应的功能，通过在HTTP请求头中使用"Range"字段指定所需的资源范围，而服务器在响应头中使用"206 Partial Content"状态码表明返回的是部分响应，并通过"Content-Range"字段指示返回内容的字节范围。这使得客户端可以请求大文件的特定部分，例如断点续传的情况下，从而避免重新下载整个文件。此外，范围请求还能让客户端只获取媒体资源的特定片段，优化数据传输并提升用户体验。

所谓的范围请求和部分响应机制，就是说客户端可以请求一个文件的某个部分，只需要在请求的头部给定文件的范围，而服务器同样也可以在响应中发送部分的响应，只需要在头部表明这是一个部分响应。



- **引入了分块传输机制：** HTTP/1.1引入了分块传输（Chunked Transfer Encoding）机制，用于在动态内容传输时，服务器无法提前确定整个内容的长度的情况下，逐块发送内容。在分块传输中，服务器将响应拆分为一系列块，每个块都有一个独立的大小，并使用"Transfer-Encoding: chunked"请求头来通知客户端有关分块传输的信息。客户端接收到该头信息后，知道响应将以分块的形式传输，它可以按照指定的块大小逐块接收内容，直到接收到一个长度为零的块，表示传输已完成。这种机制适用于动态生成内容、流式传输以及服务器长时间运行的响应等场景，提供了更灵活和高效的数据传输方式。





关于缓存机制，进一步明确： HTTP/1.1在HTTP/1.0的基础上进一步明确了缓存机制，服务器可以通过设置响应头字段来控制缓存行为：

- "Cache-Control"头字段来指定缓存策略，如"max-age"用于设置资源的最大缓存时间，"no-cache"用于要求客户端验证资源的有效性。
- 服务器也可以在响应头中添加"Expires"头字段，设置资源的过期时间，以便客户端在接收到资源后在过期时间之前可以直接使用缓存的副本。
- 另外，HTTP/1.1还支持"Last-Modified"和"If-Modified-Since"头字段，以及"ETag"和"If-None-Match"头字段，用于在客户端缓存资源后，再次请求时验证资源是否已经发生变化，如果未变化，服务器返回304 Not Modified状态码，让客户端使用缓存的资源，从而避免重复传输。、



- **添加了新的 HTTP 方法：** HTTP/1.1新增了 PUT、PATCH、OPTIONS、DELETE方法。
  - HTTP0.9——只有GET。用于从服务器获取资源的信息，通常用于读取数据。GET请求不应该对服务器的状态产生任何影响，它是**幂等**的。
  - HTTP1.0——新增了POST和HEAD
    - **POST**：用于向服务器提交数据，通常用于创建新资源。POST请求可以对服务器的状态产生影响，每次执行POST请求可能会导致不同的结果。
    - **HEAD**：类似于GET请求，但服务器只返回响应头部，不返回实际数据主体。
  - HTTP1.1:——新增了 PUT、PATCH、OPTIONS、DELETE
    - **PUT**：用于更新服务器上的资源，或者创建资源（如果不存在）。PUT请求应该是**幂等**的。
    - **DELETE**：用于从服务器删除资源。DELETE请求通常用于删除服务器上的资源。
    - **OPTIONS**：用于获取关于服务器支持的请求方法、头字段等信息。它允许客户端查询服务器的能力，以确定可以执行哪些操作。
- **新增了Host 头字段：** TTP/1.1 引入了 Host 头字段，该字段允许在同一个物理服务器上托管多个域名。这使得虚拟主机能够通过在 Host 头中指定域名来区分不同的网站。

缺陷：

- **线头阻塞（队头阻塞，Head-of-Line Blocking）：** HTTP/1.1在同一连接上使用持久连接，但由于串行发送请求和响应，如果一个请求或响应的处理时间较长，那么后续的请求和响应将被阻塞，为此它引入了管道化技术(pipelining)试图解决该问题，但它并没有完全解决这个问题，因为即使在客户端请求选择某一管道并被异步发送出去，但在服务器如果该请求前面存在缓慢或繁重的请求，那么该请求就会被阻塞。这种情况也被称为线头阻塞
- **无法处理较多的并发请求：** 由于头阻塞问题和单个连接的限制，HTTP/1.1在处理较多的并发请求时表现较差。浏览器限制了同时与同一域名建立的连接数，从而限制了并发请求的数量。
- **明文传输**
- **头部冗余：** HTTP/1.1的请求和响应头部会携带一些冗余的信息，导致了较大的头部开销，特别是对于小的资源请求。
- 没有对头部进行压缩，虽然压缩了响应的消息体。

### HTTP/2：性能更优异

仍然沿用了HTTP原有的报文格式和标准范式，为了兼容庞大的HTTP1.1用户。除了版本号，HTTP/2.0与HTTP/1.1在内容与格式上几乎没有任何差别

但是HTTP2.0由一个ASCII协议，变为了一个二级制传输的协议。其主要特性是TCP连接的多路复用，和解决了队头阻塞的问题。



特性：

- **HTTP/2.0是一个二进制协议：** 在HTTP/2.0中，HTTP不再是ASCII协议，而是二进制协议。作为一个二进制协议，它更容易解析，但与 HTTP/1.x 不同的是，它不再被人眼读取。HTTP/2 的主要构建块是帧和流，每个 HTTP/2 请求和响应都被赋予一个唯一的流 ID，并且它被分成帧。帧不过是二进制数据，帧的集合称为流。每个帧都有一个流 ID，用于标识它所属的流，并且每个帧都有一个公共标头（Type, Length, Flags, Stream Identifie）和帧有效负载，规范中一共定义了10种不同的帧，其中最基础的两种分别对应于HTTP 1.1的DATA和HEADERS。此外，流 ID 是唯一的，客户端发起的任何请求流ID都使用奇数，而来自服务器的响应流ID则都是偶数。
  - 流ID其实很像IPv4分片里的标识符。
- **多路复用：** 由于 HTTP/2 现在是二进制协议，并且正如我上面所说，它使用帧和流来进行请求和响应，因此一旦打开 TCP 连接，所有流都会通过同一连接异步发送，而无需打开任何其他连接。反过来，**服务器以**相同的**异步方式响应**，即响应没有顺序，**客户端使用分配的流 ID 来识别特定数据包所属的流**。**流的多路复用解决了 HTTP/1.x 中存在的线头阻塞问题**，即客户端不必等待正在花费时间的请求，其他请求仍将得到处理。

解决队头阻塞的方法是：多路复用，不像HTTP1.1那样要求按顺序，而是异步的处理，使用流ID来做标识。



- **头部压缩：**HTTP/2使用HPACK算法对头部信息进行压缩，减少了头部大小，从而降低了传输的数据量
- **服务器推送：**服务器可以在客户端请求之前主动将客户端可能需要的资源发送到客户端缓存中，从而避免了客户端额外的请求，减少了延迟。这种特性在某些情况下可以提高页面加载速度和性能，尤其是对于一些预加载资源或常用资源，可以减少客户端请求的往返次数。

### HTTP报文格式

虽然HTTP2使用的是二进制传输了，但是它仍然沿用了之前的报文格式，因此**用之前的报文格式来理解 HTTP/2 报文仍旧有效**。



**HTTP报文有请求、响应两种类型，它们都由起始行、消息头与消息体构成**：

- **报文的第一行被称为起始行，起始行是必须存在的**，它包含了请求/响应的基本信息。
- **报文的第二行至空白行被称为消息头，消息头有些是可选的，有些则是必须的**，它包含了一系列的key：value键值对(key不区分大小写)，用来描述请求或响应的附加信息
- **报文的空白行后一行至最后一行被称为消息体，消息体是可选的**，它用来携带请求或响应需要上传/响应的具体内容

目前HTTP的起始行和消息头仍是使用ASCII编码，而消息体则是根据消息头中的内容协商来决定具体编码方式

#### 起始行

**请求报文的起始行和响应报文的起始行是不一样的**。

请求报文的起始行：Method(请求方法)、Path(请求资源路径，通常是一个 URL)以及`HTTP/Version`(HTTP版本)组成，它们使用空格分隔。

响应报文的起始行：`HTTP/Version`(HTTP版本)、Code(状态码)以及Message(返回消息)组成，也使用空格分隔。



| 是否幂等 | 请求方法                               |
| :------- | :------------------------------------- |
| 幂等     | GET、HEAD、OPTIONS、PUT、DELETE、TRACE |
| 不幂等   | PATCH、CONNECT、POST                   |

#### 状态码

- 1xx：信息性状态码，表示服务器接收到请求并继续处理。
- 2xx：成功状态码，表示服务器成功处理了请求。
- 3xx：重定向状态码，表示需要进一步操作以完成请求。
- 4xx：客户端错误状态码，表示客户端发送的请求有错误。
- 5xx：服务器错误状态码，表示服务器在处理请求时发生了错误。
