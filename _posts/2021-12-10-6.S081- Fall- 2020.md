# Lecture - 1

## 1.1OverView

### 课程目标

1.理解操作系统的设计和实现

2.动手扩展操作系统，编写操作系统软件

### 操作系统的目的

1.抽象硬件，方便应用开发，提高可移植性，譬如软件并不关心它在和哪种类型的硬盘交互

2.在多个应用程序中共用硬件资源，一个操作系统同时运行文本编辑器，程序编译器，多个数据库等等。操作系统能在不相互干扰的前提下，同时运行这些程序。这里通常被称为multiplex。

3.由于操作系统可以同时运行许多应用程序，所以必须保证某个程序出现bug时，不会干扰到其他程序，也即隔离应用程序以容许bug

4.允许相互协作的应用程序之间共享资源，如编辑器和编译器，我们希望编辑器和编译器能共享文本文件

5.访问控制,处于安全性的考虑我们会希望某些时候我们不与其他人或者应用共享文件数据等， Control sharing for security，称为Access Control System。

6.帮助应用程序榨取硬件的最佳性能，至少不要妨碍软件获得高性能

7.希望操作系统能支持大量不同类型的应用程序。因为开发一个可用的操作系统代价极大，所以希望操作系统能万能一点

## 1.2操作系统结构

#### 内核

用一个矩形表示计算机，硬件资源包括CPU，内存，磁盘，网卡，硬件资源在最底层，这个架构的最上层我们运行各种应用程序，这些程序运行在同一个空间中，这个空间通常被称为用户空间

与运行在用户空间的应用程序不同，有一个特殊的程序总会运行，我们称之为内核，内核是计算机资源的守护者，当打开计算机时内核第一个启动。内核只有一个，负责维护数据以及管理用户空间的进程。内核还具有大量的服务，如文件系统，用户空间的程序与内核的文件系统交互，文件系统再与磁盘交互。

每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。同时，Kernel会管理内存的分配。不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。

文件系统通常有一些逻辑分区。目前而言，可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。所有这些都被文件系统所管理。

处于安全考虑的访问控制系统，当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control机制会决定是否允许这样的操作。

当然在一个真实的完备的操作系统中，会有很多很多其他的服务，比如在不同进程之间通信的进程间通信服务，比如一大票与网络关联的软件（TCP/IP协议栈），比如支持声卡的软件，比如支持数百种不同磁盘，不同网卡的驱动。所以在一个完备的系统中，Kernel会包含大量的内容，数百万行代码。

```c
* What services does an O/S kernel typically provide?
  * process (a running program)//进程管理
  * memory allocation//内存分配，内存管理
  * file contents//文件系统
  * file names, directories//文件系统相关
  * access control (security)//访问控制，安全性
  * many others: users, IPC, network, time, terminals
```

![image (64)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747443.png)

#### 应用程序与内核交互（快速预览）

应用程序通过内核的API与内核交互，API决定了应用程序如何访问内核，一般来说是通过系统调用(System Call)来完成，系统调用与程序中的函数调用看起来是一样的，但是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现

```c
* What's the application / kernel interface?
  * "System calls"
  * Examples, in C, from UNIX (e.g. Linux, macOS, FreeBSD):

            fd = open("out", 1);
            write(fd, "hello\n", 6);
            pid = fork();

  * These look like function calls but they aren't 
```

## 1.3 Why Hard and Interesting（学生提问）

1.

编写、修改，扩展内核，或者写一个新的操作系统内核时，你实际上在提供一个基础设施让别人来运行他们的程序。当程序员在写普通的应用程序时，应用程序下面都是操作系统。而当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。

2.在设计一个操作系统时，我们我们需要满足一系列相互对立的需求

- 操作系统既高效又易用，高效意味着操作系统需要在贴近硬件的低层次进行操作，而易用又需要操作系统提供抽象的高级可移植接口，所以供一个简单可移植，同时又高效的抽象接口需要一定的技巧。
- 我们想要提供一个非常强大的操作系统服务，这样操作系统才能分担运行应用程序的负担，所以我们需要强大的操作系统服务。但同时，我们也想要有简单的接口。我们不想程序员看到数量巨多，复杂且难以理解的的内核接口。因为，如果他们不理解这些接口，他们就会很难使用这些接口。所以，我们也想要简单的API。实际上是有可能提供既简单，同时又包含强大功能的接口。所以，这里要提供一个简单的接口，同时又包含了强大的功能。
- 最后一个矛盾点是所有的操作系统需要满足的。一方面给应用程序尽可能多的灵活性，你不会想要限制应用程序，所以你需要内核具备灵活的接口。但是另一方面，出于安全性考虑，又需要在某种程度上限制应用程序。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由，因为我们不想要程序员能直接访问到硬件，干扰到其他的应用程序，或者干扰操作系统的行为

```
学生提问：系统调用跳到内核与标准的函数调用跳到另一个函数相比，区别是什么？

Robert教授：Kernel的代码总是有特殊的权限。当机器启动Kernel时，Kernel会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。所以，当你执行一个普通的函数调用时，你所调用的函数并没有对于硬件的特殊权限。然而，如果你触发系统调用到内核中，内核中的具体实现会具有这些特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。我们之后会介绍更多有关的细节。
```

另一件使得操作系统的设计难且有趣的点是：**操作系统提供了大量的特性和大量的服务，但是它们趋向于相互交互。有时，这种交互以奇怪的方式进行，并且需要你大量的思考。**即使在我之前给出的一个简单例子中，对于open和fork，它们之间也可能有交互。如果一个应用程序通过open系统调用得到了一个文件描述符fd。之后这个应用程序调用了fork系统调用。fork的语义是创建一个当前进程的拷贝进程。而对于一个真正的拷贝进程，父进程中的文件描述符也必须存在且可用。所以在这里，一个通过open获得的文件描述符，与fork以这种有趣的方式进行交互。当然，你需要想明白，子进程是否能够访问到在fork之前创建的文件描述符fd。在我们要研究的操作系统中答案是，Yes，需要能够访问。

另一件有趣的事情，我之前也提到过，操作系统需要能够满足广泛的使用场景。相同的操作系统需要既给数据库服务器使用，又给智能手机使用。随着时间的推移，你的计算机所使用的硬件也在变化，所有的这些都需要时不时的重新思考，操作系统是如何被设计的。

```
学生提问：对于应用程序开发人员来说，他们会基于一些操作系统做开发，真正的深入理解这些操作系统有多重要？他们需要成为操作系统的专家吗？

Robert教授：你不必成为一个专家。但是如果你花费大量时间来开发，维护并调试应用程序，你最终还是会知道大量操作系统的知识。不论你是否是有意要掌握这些知识，它们就是出现了，而你不得不去理解它们。

学生提问：对于一些例如Python的高阶编程语言（高阶是指离自然语言更接近，低阶是指离机器语言更接近如C，汇编），它们是直接执行系统调用呢，还是内部对系统调用进行了封装呢？

Robert教授：许多高阶的编程语言都离系统调用较远，这是一个事实。部分原因是很多编程语言想要提供可以在多个操作系统上运行的可移植的环境，所以它们不能依赖特定的系统调用。所以，对于这个问题的答案我认为是，如果你使用了Python，你在某种程度上就与系统调用接口隔离了。当然，在Python内部，最终还是要执行系统调用来完成相应的工作。当然，Python和许多其他的编程语言通常都有方法能直接访问系统调用。
```

## 1.4一些系统调用

你会在第一个lab中使用我们在这里介绍的系统调用，并且在后续的lab中，扩展并提升这些系统调用的内部实现。

我们的操作系统是XV6，它运行在RISC-V微处理器上，当然不只是RISC-V微处理器，我们假设有一定数量的其他硬件存在，例如内存，磁盘和一个console接口，这样我们才能跟操作系统进行交互。但是实际上，XV6运行在QEMU模拟器之上。这样你们都能在没有特定硬件的前提下，运行XV6。

首先在shell输入make clean，这样就能看到完整的编译过程。之后输入make qemu，这条指令会编译并构建xv6内核和所有的用户进程，并将它们运行在QEMU模拟器下。$表示Shell，XV6本身很小，并且自带了一小部分的工具程序，例如ls。

### COPY.C

执行了三个系统调用，分别是read，write和exit。

read，write系统调用，它们并不关心读写的数据格式，它们就是单纯的读写，而copy程序会按照8bit的字节流处理数据，你怎么解析它们，完全是用应用程序决定的。所以应用程序可能会解析这里的数据为C语言程序，但是操作系统只会认为这里的数据是按照8bit的字节流。

```c
// copy.c: copy input to output.
#include "kernel/types.h"
#include "user/user.h"

int
main()
{
  char buf[64];

  while(1){
    int n = read(0, buf, sizeof(buf));//从输入读取一些数据，程序会预期文件描述符已经被Shell打开并设置好。
 /*read的参数，第一个为文件描述符，指向一个之前打开的文件。Shell会确保默认情况下，当一个程序启动时，文件描述符0连接到console的输入，文件描述符1连接到了console的输出。**/
 /*read的第二个参数是指向某段内存的指针，程序通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。read可以将数据保存在buf所指向的64个字节中**/
 /*read的第三个参数是代码想读取的最大长度，sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据。*/
    if(n <= 0) 	{
/*read的返回值可能是读到的字节数，在上面的截图中也就是6（xyzzy加上结束符）。read可能从一个文件读数据，如果到达了文件的结尾read会返回0。如果出现了一些错误，比如文件描述符不存在，read或许会返回-1。**/
      break;
    }
    write(1, buf, n);//将数据写入到输出
  }

  exit(0);
}
```

![image (42) (1)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747486.png)

![image (20)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747516.png)

![image (52)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747556.png)

```
学生提问：如果read的第三个参数设置成1 + sizeof(buf)会怎样？

Robert教授：如果第三个参数是65字节，操作系统会拷贝65个字节到你提供的内存中（第二个参数）。但是如果栈中的第65个字节有一些其他数据，那么这些数据会被覆盖，这里是个bug，或许会导致你的代码崩溃，或者一些异常的行为。所以，作为一个程序员，你必须要小心。C语言很容易写出一些编译器能通过的，但是最后运行时出错的代码。虽然很糟糕，但是现实就是这样。
```

## 1.5open系统调用

前面，copy代码假设文件描述符已经设置好了。但是一般情况下，我们需要能创建文件描述符，最直接的创建文件描述符的方法是open系统调用。下面是一个叫做open的源代码，它使用了open系统调用。

```c
// open.c: create a file, write to it.

#include "kernel/types.h"
#include "user/user.h"
#include "kernel/fcntl.h"
int
main()
{
//创建一个叫做output.txt的新文件，并向它写入一些数据，最后退出。我们看不到任何输出，因为它只是向打开的文件中写入数据。
  int fd = open("output.txt", O_WRONLY | O_CREATE);//open系统调用会返回一个新分配的文件描述符,一个数字
    //执行了open系统调用，将文件名output.txt作为参数传入，
    //第二个参数是一些标志位，用来告诉open系统调用在内核中的实现：我们将要创建并写入一个文件。
  write(fd, "ooo\n", 4);
/*文件描述符作为第一个参数被传到了write，write的第二个参数是数据的指针，第三个参数是要写入的字节数。数据被写入到了文件描述符对应的文件中。*/
  exit(0);
}
```

![image (65)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747601.png)

![image (57) (1)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747631.png)

![image (34)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747668.png)

**文件描述符本质上对应了内核中的一个表单数据**。内核维护了每个运行进程的状态，**内核会为每一个运行进程保存一个表单，表单的key是文件描述符。**这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，**每个进程都有自己独立的文件描述符空间，**所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是**因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。**

## 1.6Shell

相对图形化用户接口来说，这里的Shell通常也是人们说的命令行接口。Shell是一种对于Unix系统管理来说非常有用的接口，它提供了很多工具来管理文件，编写程序，编写脚本。**通常来说，当你输入内容时，你是在告诉Shell运行相应的程序。**所以当我输入ls时，实际的意义是我要求Shell运行名为ls的程序，文件系统中会有一个文件名为ls，这个文件中包含了一些计算机指令，所以实际上，**当我输入ls时，我是在要求Shell运行位于文件ls内的这些计算机指令。**

除了运行程序以外，Shell还会做一些其他的事情，比如，它允许你能重定向IO。比如，我输入 ls > out ，Shell运行ls命令，但是将输出重定向到一个叫做out的文件中。这里执行完成之后我们看不到任何的输出，因为输出都送到了out文件。现在我们知道out文件包含了一些数据，我们可以通过cat指令读取一个文件，并显示文件的内容。

![image (60)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747725.png)

![image (6)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747753.png)

你也可以运行一个名为grep的指令，并将x作为参数传给grep。grep x会搜索输入中包含x的行，我可以告诉shell将输入重定向到文件out，这样我们就可以查看out中的x。

因为out文件包含了ls的输出，所以我们可以看出有3个文件的文件名包含了x。

![image (21)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747788.png)

```c
学生提问：有一个系统调用和编译器的问题。编译器如何处理系统调用？生成的汇编语言是不是会调用一些由操作系统定义的代码段？

Robert教授：有一个特殊的RISC-V指令，程序可以调用这个指令，并将控制权交给内核。所以，实际上当你运行C语言并执行例如open或者write的系统调用时，从技术上来说，open是一个C函数，但是这个函数内的指令实际上是机器指令，//也就是说我们调用的open函数并不是一个C语言函数，它是由汇编语言实现，组成这个系统调用的汇编语言实际上在RISC-V中被称为ecall。这个特殊的指令将控制权转给内核。之后内核检查进程的内存和寄存器，并确定相应的参数。//
```

## 1.7Fork

fork会创建一个新的进程，下面是使用fork的一个简单用例。

```c
// fork.c: create a new process
#include "kernel/types.h"
#include "user/user.h"
int main()
{
  int pid;

  pid = fork();
/*fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后，我们就有了两个拥有完全一样内存的进程。*/
/**fork系统调用在两个进程中都会返回*/
  printf("fork() returned %d\n", pid);/*在新创建的进程中，fork系统调用会返回0。**/
/*在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。*/
    //所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。
  if(pid == 0){//pid == 0说明fork返回了0。说明当前进程是子进程
    printf("child\n");
  } else {//否则pid > 0 ，当前进程是父进程
    printf("parent\n");
  }
  
  exit(0);
}
//运行得到的输出：
```

![image (67)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747821.png)

输出看起来像是垃圾数据。这里实际发生的是，**fork系统调用之后，两个进程都在同时运行**，QEMU实际上是在模拟多核处理器，所以这两个进程实际上就是同时在运行。所以当这**两个进程在输出的时候，它们会同时一个字节一个字节的输出，两个进程的输出交织在一起**，所以你可以看到两个f，两个o等等。在第一行最后，你可以看到0，这是子进程的输出。我猜父进程返回了19，作为子进程的进程ID。**通常来说，这意味着这是操作系统启动之后的第19个进程。**之后一个进程输出了child，一个进程输出了parent，这两个输出交织在一起。虽然这只是对于fork的一个简单应用，但是我们可以清晰的从输出看到这里创建了两个运行的进程，其中一个进程打印了child，另一个打印了parent。所以，fork（在子父进程中）返回不同的值是比较重要的。

```c
学生提问：fork产生的子进程是不是总是与父进程是一样的？它们有可能不一样吗？

Robert教授：/*在XV6中，除了fork的返回值，两个进程是一样的。两个进程的指令是一样的，数据是一样的，栈是一样的，同时，两个进程又有各自独立的地址空间，它们都认为自己的内存从0开始增长，但这里是不同的内存。*/ 在一个更加复杂的操作系统，有一些我们现在并不关心的细节，这些细节偶尔会导致父子进程不一致，但是在XV6中，父子进程除了fork的返回值，其他都是一样的。/*除了内存是一样的以外，文件描述符的表单也从父进程拷贝到子进程。所以如果父进程打开了一个文件，子进程可以看到同一个文件描述符，尽管子进程看到的是一个文件描述符的表单的拷贝。除了拷贝内存以外，fork还会拷贝文件描述符表单这一点还挺重要的，我们接下来会看到。*/
```

fork创建了一个新的进程。当我们在Shell中运行东西的时候，Shell实际上会创建一个新的进程来运行你输入的每一个指令。所以，当我输入ls时，我们需要Shell通过fork创建一个进程来运行ls，这里需要某种方式来让这个新的进程来运行ls程序中的指令，加载名为ls的文件中的指令（也就是后面的exec系统调用）。

## 1.8exec, wait系统调用

### exec

在接下来我展示的一个例子中，会使用echo，echo是一个非常简单的命令，它接收任何你传递给它的输入，并将输入写到输出。

![image (24)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747858.png)

```c

// exec.c: replace a process with an executable file
//等价于运行echo命令，并带上“this is echo” 这三个参数。
#include "kernel/types.h"
#include "user/user.h"
/*代码会执行exec系统调用，这个系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。*/
int
main()
{
  char *argv[] = { "echo", "this", "is", "echo", 0 };
/*操作系统从名为echo的文件中加载指令到当前的进程中，并替换了当前进程的内存，之后开始执行这些新加载的指令。*/
  exec("echo", argv);
/*你可以传入命令行参数，exec允许你传入一个命令行参数的数组，这里就是一个C语言中的指针数组，在上面代码的第10行设置好了一个字符指针的数组，这里的字符指针本质就是一个字符串（string）。*/
  printf("exec failed!\n");//正常情况下这句话永远也不会被打印出来，因为exec根本不会返回

  exit(0);
}
```

![image (66)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747883.png)

有关exec系统调用，有一些重要的事情，

1. **exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。**
2. 通常来说exec系统调用不会返回，**因为exec会完全替换当前进程的内存**，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。

所以，exec系统调用从文件中读取指令，执行这些指令，然后就没有然后了。exec系统调用只会在出错时才会返回，因为某些错误会阻止操作系统为你运行文件中的指令，例如程序文件根本不存在，因为exec系统调用不能找到文件，exec会返回-1来表示：出错了，我找不到文件。所以通常来说exec系统调用不会返回，它只会在kernel不能运行相应的文件时返回。

```
学生提问：argv中的最后一个0是什么意思？

Robert教授：它标记了数组的结尾。C是一个非常低阶（接近机器语言）的编程语言，并没有一个方法来确定一个数组究竟有多长。所以为了告诉内核数组的结尾在哪，我们将0作为最后一个指针。argv中的每一个字符串实际上是一块包含了数据的内存指针，但是第5个元素是0，通常来说指针0是一个NULL指针，它只表明结束。所以内核中的代码会遍历这里的数组，直到它找到了值为0的指针。
```

### fork

实际上，当我们在Shell中运行类似于“echo a b c”的指令，或者ls，或者任何命令，我们不会想要代替Shell进程，所以我们不会希望Shell执行exec系统调用。如果我们这么做了，这里会用echo指令来替代Shell进程，当echo退出了，一切就结束了。所以我们不想要echo替代Shell。

**实际上，Shell会执行fork，之后fork出的子进程再调用exec系统调用，这是一个非常常见的Unix程序调用风格。对于那些想要运行程序，但是还希望能拿回控制权的场景，可以先执行fork系统调用，然后在子进程中调用exec。**

这里有一个简单的例子，来演示fork/exec程序。

```c

#include "kernel/types.h"
#include "user/user.h"

// forkexec.c: fork then exec

int
main()
{
  int pid, status;
  pid = fork();
  if(pid == 0){//line 13
    char *argv[] = { "echo", "THIS", "IS", "ECHO", 0 };
    exec("echo", argv);
    printf("exec failed!\n");
    exit(1);
  } else {//line 19
    printf("parent waiting\n");
    wait(&status);//Unix提供了一个wait系统调用，wait会等待之前创建的子进程退出。
/*所以wait系统调用，使得父进程可以等待任何一个子进程返回。wait系统调用只能等待当前进程的子进程。*/
/*参数status，是一种让退出的子进程以一个整数（32bit的数据）的格式与等待的父进程通信方式。所以在第17行，exit的参数是1，操作系统会将1从退出的子进程传递到第20行，&status，是将status对应的地址传递给内核，内核 会向这个地址 写入 子进程向exit传入的参数。*/
    printf("the child exited with status %d\n", status);
  }
  exit(0);
}
```

子进程从第14行开始，我们在子进程中与前一个程序一样调用exec。子进程会用echo命令来代替自己，echo执行完成之后就退出。之后父进程重新获得了控制。fork会在父进程中返回大于0的值，父进程会继续在第19行执行。

这里是一个常用的写法，**先调用fork，再在子进程中调用exec**。这里实际上有些浪费，fork首先拷贝了整个父进程的，但是之后exec整个将这个拷贝丢弃了，并用你要运行的文件替换了内存的内容。某种程度上来说这里的拷贝操作浪费了，因为所有拷贝的内存都被丢弃并被exec替换。在大型程序中这里的影响会比较明显。如果你运行了一个几G的程序，并且调用fork，那么实际就会拷贝所有的内存，可能会要消耗将近1秒钟来完成拷贝，这可能会是个问题。

在这门课程的后面，你们会实现一些优化，比如说copy-on-write fork，这种方式会消除fork的几乎所有的明显的低效，而只拷贝执行exec所需要的内存，这里需要很多涉及到虚拟内存系统的技巧。你可以构建一个fork，对于内存实行lazy拷贝，通常来说fork之后立刻是exec，这样你就不用实际的拷贝，因为子进程实际上并没有使用大部分的内存。我认为你们会觉得这将是一个有趣的实验。

![image (71)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747922.png)

```c
学生提问：为什么父进程在子进程调用exec之前就打印了“parent waiting”？

Robert教授：/*这里只是巧合。*/父进程的输出有可能与子进程的输出交织在一起，就像我们之前在fork的例子中看到的一样，只是这里正好没有发生而已。并不是说我们一定能看到上面的输出，实际上，如果看到其他的输出也不用奇怪。我怀疑这里背后的原因是，exec系统调用代价比较高，它需要访问文件系统，访问磁盘，分配内存，并读取磁盘中echo文件的内容到分配的内存中，分配内存又可能需要等待内存释放。所以，exec系统调用背后会有很多逻辑，很明显，处理这些逻辑的时间足够长，这样父进程可以在exec开始执行echo指令之前完成输出。这样说得通吧？
/******************************/
学生提问：子进程可以等待父进程吗？

Robert教授：Unix并没有一个直接的方法让子进程等待父进程。/*wait系统调用只能等待当前进程的子进程。所以wait的工作原理是，如果当前进程有任何子进程，并且其中一个已经退出了，那么wait会返回。*/但是如果当前进程没有任何子进程，比如在这个简单的例子中，如果子进程调用了wait，因为子进程自己没有子进程了，所以wait会立即返回-1，表明出现错误了，当前的进程并没有任何子进程。

简单来说，不可能让子进程等待父进程退出。
/**************************下面那个为重要问题*****************************************/
学生提问：当我们说子进程从父进程拷贝了所有的内存，这里具体指的是什么呢？是不是说子进程需要重新定义变量之类的？

Robert教授：在编译之后，你的C程序就是一些在内存中的指令，这些指令存在于内存中。所以这些指令可以被拷贝，因为它们就是内存中的字节，它们可以被拷贝到别处。通过一些有关虚拟内存的技巧，可以使得子进程的内存与父进程的内存一样，/*这里实际就是将父进程的内存镜像拷贝给子进程，并在子进程中执行。*/

/*实际上，当我们在看C程序时，你应该认为它们就是一些机器指令，这些机器指令就是内存中的数据，所以可以被拷贝。*/

学生提问：如果父进程有多个子进程，wait是不是会在第一个子进程完成时就退出？这样的话，还有一些与父进程交错运行的子进程，是不是需要有多个wait来确保所有的子进程都完成？

Robert教授：是的，/*如果一个进程调用fork两次，如果它想要等两个子进程都退出，它需要调用wait两次。每个wait会在一个子进程退出时立即返回。当wait返回时，你实际上没有必要知道哪个子进程退出了，但是wait返回了子进程的进程号，所以在wait返回之后，你就可以知道是哪个子进程退出了。*/
```

## 1.9I/O Redirect

最后一个例子，展示一下将所有这些工具结合在一起，来实现I/O重定向。

```c

#include "kernel/types.h"
#include "user/user.h"
#include "kernel/fcntl.h"

// redirect.c: run a command with output redirected

int
main()
{
  int pid;

  pid = fork();//line 13
  if(pid == 0){
    close(1);
    open("output.txt", O_WRONLY|O_CREATE);

    char *argv[] = { "echo", "this", "is", "redirected", "echo", 0 };
    exec("echo", argv);
    printf("exec failed!\n");
    exit(1);
  } else {
    wait((int *) 0);
  }

  exit(0);
}
x1.00
```

之前讲过，Shell提供了方便的I/O重定向工具。如果我运行下面的指令，Shell会将echo的输出送到文件out。之后我们可以运行cat指令，并将out文件作为输入，我们可以看到保存在out文件中的内容就是echo指令的输出。

![ 	](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747947.png)

![image (45)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747986.png)

Shell之所以有这样的能力，是因为Shell首先会像第13行一样fork，然后在子进程中，Shell改变了文件描述符。**文件描述符1通常是进程用来作为输出的（也就是console的输出文件符），Shell会将文件描述符1改为output文件，之后再运行你的指令。**同时，父进程的文件描述符1并没有改变。所以这里**先fork，再更改子进程的文件描述符，**是Unix中的常见的用来重定向指令的输入输出的方法，这种方法同时又不会影响父进程的输入输出。因为我们不会想要重定向Shell的输出，我们只想重定向子进程的输出。



代码的第15行只会在子进程中执行。代码的第15行的意义是重定向echo命令的输出，如果我运行整个程序redirect程序,可以看到没有任何的输出。但是实际上redirect程序里面运行了echo，只是echo的输出重定向到了output.txt。如果我们查看output.txt，我们可以看到预期的输出。

![image (25)](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747010.png)

**代码第16行的open一定会返回1，因为open会返回当前进程未使用的最小文件描述符序号。**因为我们刚刚关闭了文件描述符1，而文件描述符0还对应着console的输入，所以open一定可以返回1。**在代码第16行之后，文件描述符1与文件output.txt关联。**

之后我们执行exec(echo)，**echo会输出到文件描述符1**，也就是文件output.txt。**这里有意思的地方是，echo根本不知道发生了什么，echo也没有必要知道I/O重定向了，它只是将自己的输出写到了文件描述符1。**只有Shell知道I/O重定向了。

## xv6book - chapter 1

操作系统的工作是(**1)将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身更有用的服务。(2)管理并抽象底层硬件，举例来说，一个文字处理软件（比如 word）不用去关心自己使用的是何种硬盘。(3)多路复用硬件，使得多个程序可以(至少看起来是)同时运行的。(4)最后，给程序间提供一种受控的交互方式，使得程序之间可以共享数据、共同工作。**

![f0-1](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111051747056.png)



传统的**内核**概念 - **一个向其他运行中程序提供服务的特殊程序。**每一个运行中程序（称之为**进程**）都拥有包含**指令、数据、栈**的内存空间。**指令实现了程序的运算，数据是用于运算过程的变量，栈管理了程序的过程调用。**

进程通过**系统调用**使用内核服务。**系统调用会进入内核，让内核执行服务然后返回。**所以**进程总是在用户空间和内核空间之间交替运行。**

。**shell 作为一个普通程序，而不是内核的一部分，充分说明了系统调用接口的强大：shell 并不是一个特别的用户程序。这也意味着 shell 是很容易被替代的**

一个 xv6 进程由两部分组成，一部分是用户内存空间（指令，数据，栈），另一部分是仅对内核可见的进程状态。

内核将每个进程和一个 **pid** (process identifier) 关联起来。

`fork` 创建的新进程被称为**子进程**，子进程的**内存内容**同创建它的进程（父进程）一样。
